//! Agent runner for executing the multi-step agentic narrative workflow.

use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{debug, error, info, warn};
use uuid::Uuid;
use secrecy::ExposeSecret;

use crate::{
    auth::session_dek::SessionDek,
    errors::AppError,
    llm::AiClient,
    models::{
        chats::ChatMessage,
        chronicle::CreateChronicleRequest,
    },
    services::{ChronicleService, hybrid_token_counter::{HybridTokenCounter, CountingMode}},
};

use super::{
    registry::ToolRegistry,
    tools::{ToolParams, ToolResult},
};

/// Configuration for the narrative intelligence workflow
#[derive(Debug, Clone)]
pub struct NarrativeWorkflowConfig {
    /// Model to use for triage analysis (should be fast and cheap)
    pub triage_model: String,
    /// Model to use for reasoning and planning (can be more capable)
    pub planning_model: String,
    /// Maximum number of tools that can be executed in a single workflow
    pub max_tool_executions: usize,
    /// Whether to enable cost-saving optimizations
    pub enable_cost_optimizations: bool,
}

impl Default for NarrativeWorkflowConfig {
    fn default() -> Self {
        Self {
            triage_model: "gemini-2.5-flash-lite-preview-06-17".to_string(),
            planning_model: "gemini-2.5-flash-lite-preview-06-17".to_string(),
            max_tool_executions: 5,
            enable_cost_optimizations: true,
        }
    }
}

/// Result of the triage analysis step
#[derive(Debug, Clone)]
pub struct TriageResult {
    pub is_significant: bool,
    pub summary: String,
    pub event_type: String,
    pub confidence: f32,
}

/// A plan of action generated by the AI agent
#[derive(Debug, Clone)]
pub struct ActionPlan {
    pub reasoning: String,
    pub actions: Vec<PlannedAction>,
}

/// A single action in the plan
#[derive(Debug, Clone)]
pub struct PlannedAction {
    pub tool_name: String,
    pub parameters: ToolParams,
    pub reasoning: String,
}

/// Core agent runner that orchestrates the narrative intelligence workflow
pub struct NarrativeAgentRunner {
    ai_client: Arc<dyn AiClient>,
    tool_registry: Arc<ToolRegistry>,
    config: NarrativeWorkflowConfig,
    chronicle_service: Arc<ChronicleService>,
    token_counter: Arc<HybridTokenCounter>,
}

impl NarrativeAgentRunner {
    pub fn new(
        ai_client: Arc<dyn AiClient>,
        tool_registry: Arc<ToolRegistry>,
        config: NarrativeWorkflowConfig,
        chronicle_service: Arc<ChronicleService>,
        token_counter: Arc<HybridTokenCounter>,
    ) -> Self {
        Self {
            ai_client,
            tool_registry,
            config,
            chronicle_service,
            token_counter,
        }
    }

    /// Execute the full narrative intelligence workflow for a set of chat messages
    pub async fn process_narrative_event(
        &self,
        user_id: Uuid,
        chat_session_id: Uuid,
        mut chronicle_id: Option<Uuid>,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
        persona_context: Option<super::UserPersonaContext>,
    ) -> Result<NarrativeWorkflowResult, AppError> {
        info!(
            "Starting narrative workflow for chat {} with {} messages",
            chat_session_id,
            messages.len()
        );

        // Step 1: Triage - Is this significant?
        let triage_result = self.perform_triage(user_id, chronicle_id, messages, session_dek, persona_context.as_ref()).await?;
        
        if !triage_result.is_significant {
            info!("Triage determined event is not significant, skipping workflow");
            return Ok(NarrativeWorkflowResult {
                triage_result,
                actions_taken: vec![],
                execution_results: vec![],
                cost_estimate: 0.0,
            });
        }

        info!("Event deemed significant: {}", triage_result.summary);

        // Track whether we just created a new chronicle
        let mut chronicle_was_just_created = false;

        // Auto-create and link chronicle if this is the first significant event for this chat
        if chronicle_id.is_none() {
            info!("Auto-creating chronicle for chat session {}", chat_session_id);
            
            // Generate a meaningful chronicle name based on the chat context
            let chronicle_name = self.generate_chronicle_name_from_messages(messages, session_dek).await?;
            let chronicle_description = format!(
                "Automatically created chronicle for chat session on {}",
                chrono::Utc::now().format("%Y-%m-%d %H:%M UTC")
            );
            
            let chronicle_request = CreateChronicleRequest {
                name: chronicle_name,
                description: Some(chronicle_description),
            };
            
            match self.chronicle_service.create_chronicle(user_id, chronicle_request).await {
                Ok(created_chronicle) => {
                    chronicle_id = Some(created_chronicle.id);
                    chronicle_was_just_created = true;
                    info!("Auto-created chronicle '{}': {}", created_chronicle.name, created_chronicle.id);
                    
                    // Link the chat session to the chronicle
                    if let Err(e) = self.chronicle_service.link_chat_session(user_id, chat_session_id, created_chronicle.id).await {
                        error!("Failed to link chronicle {} to chat session {}: {}", created_chronicle.id, chat_session_id, e);
                        // Continue anyway - the chronicle exists
                    } else {
                        info!("Successfully linked chronicle {} to chat session {}", created_chronicle.id, chat_session_id);
                    }
                },
                Err(e) => {
                    error!("Failed to auto-create chronicle for chat session {}: {}", chat_session_id, e);
                    // Continue without chronicle - events will be skipped but workflow continues
                }
            }
        }

        // Step 2: Knowledge Retrieval - What do we already know?
        let knowledge_context = self.retrieve_knowledge_context(&triage_result).await?;

        // Step 3: Planning - What should we do?
        let action_plan = self.generate_action_plan(
            &triage_result,
            &knowledge_context,
            chronicle_id,
            chronicle_was_just_created, // Pass this information to the planner
            persona_context.as_ref(),
        ).await?;

        info!("Generated action plan with {} actions", action_plan.actions.len());

        // Step 4: Execution - Execute the planned actions
        let execution_results = self.execute_action_plan(&action_plan, user_id, chronicle_id, session_dek, persona_context.as_ref()).await?;

        Ok(NarrativeWorkflowResult {
            triage_result,
            actions_taken: action_plan.actions,
            execution_results,
            cost_estimate: 0.0, // TODO: Implement cost tracking
        })
    }

    /// Step 1: Analyze if the conversation contains significant narrative events
    async fn perform_triage(
        &self,
        user_id: Uuid,
        chronicle_id: Option<Uuid>,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
        persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<TriageResult, AppError> {
        debug!("Performing narrative triage on {} messages", messages.len());

        // Build conversation text
        let conversation_text = self.build_conversation_text(messages, session_dek).await?;

        // Get comprehensive chronicle context with XML labeling for deduplication
        let recent_chronicles_context = if let Some(chron_id) = chronicle_id {
            self.get_recent_chronicle_context_with_xml_labeling(user_id, chron_id).await.unwrap_or_default()
        } else {
            String::new()
        };
        
        // Build persona context section
        let persona_section = if let Some(persona) = persona_context {
            format!("\n{}\n", persona.to_prompt_context())
        } else {
            String::new()
        };

        let triage_prompt = format!(
            r#"🚨 ANTI-DUPLICATION MISSION: Your primary job is to PREVENT creating chronicle events for things that are already chronicled.

🎯 CORE QUESTION: "Is this conversation describing NEW narrative developments that are NOT already covered in the existing chronicles shown below?"

📋 XML LABELING ACTIVE: Existing chronicle events are clearly marked below. You can see ALL relevant context but must NOT duplicate what already exists.

Analyze this roleplay conversation and determine if it contains narratively significant events that are NOT already covered by the existing chronicles.
{}
CONVERSATION:
{}

<EXISTING_CHRONICLES>
<!-- DO NOT DUPLICATE: These events already exist in the chronicle -->
{}
</EXISTING_CHRONICLES>

You are analyzing according to the Ars Fabula narrative ontology. Respond with a JSON object:
{{
    "is_significant": boolean, // true if this contains events worth recording
    "summary": "string", // brief summary of what happened (if significant)
    "event_category": "string", // Primary narrative pillar: WORLD, CHARACTER, PLOT, RELATIONSHIP
    "event_type": "string", // Abstract category: DISCOVERY, ALTERATION, LORE_EXPANSION, STATE_CHANGE, DEVELOPMENT, PROGRESSION, REVELATION, TURNING_POINT, FORMATION, MODIFICATION, INTERACTION
    "narrative_action": "string", // Core verb: DISCOVERED, REVEALED, MET, ATTACKED, ACQUIRED, DIED, BETRAYED, TOLD, DECIDED, etc.
    "primary_agent": "string", // Name of entity initiating the action (if any)
    "primary_patient": "string", // Name of entity being acted upon (if any)
    "confidence": float // 0.0-1.0 confidence in this assessment
}}

SIGNIFICANCE CRITERIA (Ars Fabula Event Ontology):

WORLD Events (Changes to the physical/conceptual reality):
- DISCOVERY + DISCOVERED/FOUND: New locations, items, secrets, knowledge
- ALTERATION + TRANSFORMED/CHANGED: Environmental changes, world state shifts  
- LORE_EXPANSION + REVEALED/TOLD: Learning history, understanding mechanics

CHARACTER Events (Individual entity changes):
- STATE_CHANGE + DIED/TRANSFORMED: Death, injury, fundamental change
- DEVELOPMENT + ACQUIRED/EVOLVED: Skill gains, power increases, growth
- PROGRESSION + DECIDED/COMMITTED: Character arc advancement, goal changes

PLOT Events (Narrative structure progression):
- REVELATION + REVEALED/DISCOVERED: Secrets uncovered, mysteries solved
- TURNING_POINT + DECIDED/CHOSE: Critical decisions, plot branches
- PROGRESSION + ADVANCED/COMPLETED: Quest advancement, story milestone

RELATIONSHIP Events (Social dynamics):
- FORMATION + MET/BEFRIENDED: New relationships, alliances formed
- MODIFICATION + BETRAYED/CHANGED: Relationship shifts, trust changes
- INTERACTION + TOLD/ASKED: Significant dialogue, negotiations

Examples:
- Character death: WORLD.STATE_CHANGE + DIED, agent=killer, patient=victim
- Meeting someone: RELATIONSHIP.FORMATION + MET, agent=character1, patient=character2
- Finding treasure: WORLD.DISCOVERY + DISCOVERED, agent=finder, object=treasure
- Learning secret: PLOT.REVELATION + REVEALED, agent=revealer, patient=learner

Consider NOT significant:
- Routine conversation without impact
- Movement without discovery or consequence  
- Minor interactions without relationship change
- Events already covered in recent chronicle entries (check RECENT CHRONICLE EVENTS above)
- Scene details that don't advance the plot or change world state
- Sexual content without narrative significance or character development
- Repetitive interactions already documented

COALESCING RULE (Critical for Event Quality):
- **AFTERMATH vs NEW EVENT**: Emotional reactions, satisfaction, pride, or contemplation following recent events should NOT be chronicled separately
- **VALENCE DATA**: These emotional states belong as metadata in the original event, NOT as new chronicle entries
- **FOLLOW-UP ACTIONS**: Minor actions immediately after significant events (moving to another room, etc.) are usually NOT significant
- **CONVERSATION CONTINUATION**: If the content primarily describes ongoing or recent actions without new consequences, mark as NOT significant
- **SPECIFIC EXAMPLE**: If chronicle context shows "Sol secured Executive Suite", then conversation about "Sol feeling satisfied with the security" or "Sol and Lumiya entering the room" should be marked NOT significant

TEMPORAL SCOPE PRIORITIZATION:
- Prioritize MAJOR PLOT EVENTS over scene details
- Focus on actions with lasting consequences over momentary interactions  
- Divine interventions, world-changing events, and character arcs take precedence
- Distinguish between story beats (significant) vs flavor text (insignificant)
- Events spanning longer time periods (months, years) are typically more significant than minute-by-minute actions
- Global consequences and governmental responses indicate high significance

DEDUPLICATION RULES (CRITICAL - MUST FOLLOW):
- **MANDATORY CHECK**: If ANY similar event is in <EXISTING_CHRONICLES> above, mark as NOT significant
- **SEMANTIC OVERLAP**: If the conversation describes the same ACTION + ACTOR + CONTEXT as existing chronicles, mark as NOT significant
- **REDUNDANCY CHECK**: If this conversation is just describing what was already chronicled, mark as NOT significant
- **EMOTIONAL AFTERMATH**: If this is just emotional reaction to an existing chronicled event, mark as NOT significant
- **SCENE TRANSITIONS**: Moving between locations or routine actions without new consequences are NOT significant
- **WHEN IN DOUBT**: Choose NOT significant rather than risk duplication
- **XML CONTEXT**: Use the <EXISTING_CHRONICLES> section as your primary reference for what already exists

IMPORTANT: When identifying characters in the conversation, use the persona context above to properly identify who is who. Do not refer to characters generically as "the user" or "the character" when you have specific persona information available."#,
            persona_section,
            conversation_text,
            recent_chronicles_context
        );

        // Call AI for triage
        let response = self.call_ai_structured(&self.config.triage_model, &triage_prompt).await?;

        // Parse response
        let is_significant = response.get("is_significant")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        let summary = response.get("summary")
            .and_then(|v| v.as_str())
            .unwrap_or("No summary provided")
            .to_string();

        let event_type = response.get("event_type")
            .and_then(|v| v.as_str())
            .unwrap_or("UNKNOWN")
            .to_string();

        let confidence = response.get("confidence")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5) as f32;

        Ok(TriageResult {
            is_significant,
            summary,
            event_type,
            confidence,
        })
    }

    /// Step 2: Retrieve relevant knowledge from existing chronicles/lorebooks
    async fn retrieve_knowledge_context(
        &self,
        triage_result: &TriageResult,
    ) -> Result<Value, AppError> {
        debug!("Retrieving knowledge context for: {}", triage_result.summary);

        // Use the search tool to find relevant context
        let search_tool = self.tool_registry.get_tool("search_knowledge_base")
            .map_err(|e| AppError::InternalServerErrorGeneric(format!("Search tool not available: {}", e)))?;

        let search_params = json!({
            "query": triage_result.summary,
            "search_type": "all",
            "limit": 10
        });

        match search_tool.execute(&search_params).await {
            Ok(results) => Ok(results),
            Err(e) => {
                warn!("Knowledge search failed: {}", e);
                // Return empty context on failure
                Ok(json!({"results": []}))
            }
        }
    }

    /// Step 3: Generate an action plan based on the event and existing knowledge
    async fn generate_action_plan(
        &self,
        triage_result: &TriageResult,
        knowledge_context: &Value,
        chronicle_id: Option<Uuid>,
        chronicle_was_just_created: bool,
        persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<ActionPlan, AppError> {
        debug!("Generating action plan for event: {}", triage_result.event_type);

        // Dynamically build available tools list based on what's actually registered
        let available_tools = self.tool_registry.list_tools();
        let mut tools_description = String::new();
        
        for tool_name in &available_tools {
            match tool_name.as_str() {
                "create_chronicle_event" => {
                    tools_description.push_str("- create_chronicle_event: Record temporal, player-centric events that happened at specific times\n");
                }
                "create_lorebook_entry" => {
                    tools_description.push_str("- create_lorebook_entry: Create NEW lorebook entries for persistent world concepts (characters, locations, items, lore)\n");
                }
                "update_lorebook_entry" => {
                    tools_description.push_str("- update_lorebook_entry: Update existing lorebook entries when world state changes\n");
                }
                "search_knowledge_base" => {
                    tools_description.push_str("- search_knowledge_base: Find existing information (already done above)\n");
                }
                _ => {
                    // Skip other tools that aren't relevant for planning
                }
            }
        }

        // Build persona context section
        let persona_section = if let Some(persona) = persona_context {
            format!("\n{}\n", persona.to_prompt_context())
        } else {
            String::new()
        };

        let planning_prompt = format!(
            r#"🚨 ANTI-DUPLICATION MISSION: Before creating ANY chronicle events, you MUST verify they don't duplicate existing content.

🔍 MANDATORY DUPLICATE CHECK:
1. Read the <EXISTING_CHRONICLES> section below carefully
2. Compare any planned events against what's already chronicled
3. If similar events exist (same action + actor + context), DO NOT create new events
4. Focus only on genuinely NEW narrative developments

📋 XML LABELING ACTIVE: You can see ALL existing chronicle events clearly marked below. Use this context to prevent duplicates while ensuring you have complete narrative awareness.

You are an Ars Fabula narrative intelligence agent. Based on the event analysis, create a plan to update the narrative knowledge base with ONLY new, non-duplicate content.
{}
EVENT ANALYSIS:
- Type: {}
- Summary: {}
- Confidence: {}

<EXISTING_CHRONICLES>
<!-- DO NOT DUPLICATE: These events already exist in the chronicle -->
{}
</EXISTING_CHRONICLES>

AVAILABLE TOOLS:
{}

CHRONICLE ID: {}
CHRONICLE JUST CREATED: {}

{}

Create a JSON plan following Ars Fabula principles:
{{
    "reasoning": "string explaining your logic and narrative impact",
    "actions": [
        {{
            "tool_name": "string",
            "parameters": {{}},
            "reasoning": "string explaining why this action advances the Fabula"
        }}
    ]
}}

SIMPLIFIED CHRONICLE RULES:

1.  **CHRONICLE EVENTS (for create_chronicle_event):**
    *   **Purpose:** Capture significant narrative moments as searchable text summaries
    *   **`event_type`:** Use simple dot-notation: `NARRATIVE.EVENT` (keep it simple)
    *   **`summary`:** A rich, narrative description of what happened (see writing principles below)
    *   **`keywords`:** Extract 3-5 searchable terms from the event (character names, locations, important objects, actions)

2.  **PERSISTENT CONCEPTS (for create_lorebook_entry):**
    *   Create entries for **new, persistent entities** (characters, locations, items, organizations) that are likely to be mentioned again.
    *   Focus on timeless, factual information.

3.  **KNOWLEDGE INTEGRATION:**
    *   **CRITICAL:** Review <EXISTING_CHRONICLES> to avoid creating duplicate events or lorebook entries.
    *   If a similar event exists, consider if this is truly new information worth chronicling.
    *   **XML GUIDANCE:** The <EXISTING_CHRONICLES> section shows ALL relevant events - do not duplicate what's already there.

4.  **CRAFTING IMMERSIVE EVENT SUMMARIES (The Most Important Part):**
    
    The `summary` field is what users see and what gets fed back to the AI in future prompts. It should read like a gripping excerpt from an epic novel, not a dry database entry.
    
    **INCLUDE ALL OF THESE ELEMENTS:**
    *   **WHO:** Character names and their relationship dynamics
    *   **WHAT:** The dramatic action with emotional weight  
    *   **WHERE:** Atmospheric setting details that set the scene
    *   **WHY:** Motivations, stakes, and what drove this moment
    *   **HOW:** The method, style, or emotional texture of the action
    *   **IMPACT:** Why this moment matters to the larger story
    
    **EXAMPLES OF TRANSFORMATION:**
    
    ❌ BAD (Current): "Sol secured a meeting with Grakol in his office to discuss a 'big problem'."
    
    ✅ GOOD (Target): "Sol's brutal reputation for annihilating the Crimson Cutters earned him a tense private audience in Grakol's smoke-filled back office, where the cantina owner's impressed gaze held the promise of a job that could change everything."
    
    ❌ BAD: "Sol paid 15 credits for two drinks."
    
    ✅ GOOD: "Sol slid 15 credits across the grimy bar to Grakol at The Grimy Pit, the simple transaction carrying undertones of respect between two beings who understood the weight of credits earned through violence."
    
    **SUMMARY WRITING PRINCIPLES:**
    *   Write like you're crafting the most addictive story ever told
    *   Capture the emotional undertones and atmospheric details
    *   Show character relationships and power dynamics
    *   Include sensory details that make the scene vivid
    *   Hint at larger implications and consequences
    *   Make every event feel like it matters to the epic narrative

5.  **SIMPLIFIED JSON EXAMPLES for `create_chronicle_event`:**

**Example 1 - Character Development:**
```json
{{
    "tool_name": "create_chronicle_event",
    "parameters": {{
        "event_type": "NARRATIVE.EVENT",
        "summary": "In the heat of brutal combat training, Sol finally broke through his limitations and mastered the deadly art of advanced Force projection under Lumiya's ruthless tutelage, the achievement marking his transformation from apprentice to true warrior.",
        "keywords": ["Sol Steele", "Lumiya", "Force projection", "training", "mastery"],
        "timestamp_iso8601": "2025-06-28T15:30:00Z"
    }},
    "reasoning": "This represents a significant character progression that will affect future interactions and abilities"
}}
```

**Example 2 - Plot Revelation:**
```json
{{
    "tool_name": "create_chronicle_event",
    "parameters": {{
        "event_type": "NARRATIVE.EVENT",
        "summary": "In the shadowy depths of the cantina's back room, the nervous informant's whispered revelation shattered everything—the Empire had been hunting Asset Zeta-Six for months, their web of surveillance closing like a noose around the unsuspecting target.",
        "keywords": ["informant", "Empire", "Asset Zeta-Six", "surveillance", "revelation"],
        "timestamp_iso8601": "2025-06-28T15:45:00Z"
    }},
    "reasoning": "This revelation fundamentally changes the character's understanding of their situation and will drive future plot decisions"
}}
```

6.  **ENHANCED DEDUPLICATION RULES (CRITICAL - MUST FOLLOW):**
    *   **STEP 1 - SEMANTIC COMPARISON**: Before creating ANY event, compare its core elements against ALL existing chronicle context:
        - Same ACTION (secured, mastered, met, etc.) + Same SUBJECT/ACTOR + Similar TIMEFRAME = DUPLICATE
        - Same LOCATION + Same TYPE of interaction + Same CHARACTERS = DUPLICATE  
        - Same EMOTIONAL STATE or REACTION to recent major event = DUPLICATE
    *   **STEP 2 - TEMPORAL REDUNDANCY CHECK**: If conversation text is describing something that just happened in the messages, AND similar events exist in chronicle context, DO NOT create new event
    *   **STEP 3 - CONSEQUENCE vs CONTINUATION**: Ask "Is this a NEW narrative consequence, or just describing/continuing what already happened?"
    *   **STEP 4 - WHEN IN DOUBT**: Choose NOT to create an event rather than risk duplication
    *   **EXAMPLES OF WHAT NOT TO CHRONICLE**:
        - "Sol secured Executive Suite" (if already chronicled)
        - "Sol used multitool to secure room" (if room security already chronicled)  
        - "Sol and Lumiya headed to meeting" (if meeting arrangement already chronicled)
        - Emotional reactions to events that just got chronicled
        - Scene transitions without new narrative content

5.  ONLY use tools listed in AVAILABLE TOOLS above.
6.  Prioritize narrative significance and causal coherence.
7.  Ensure events contribute meaningfully to the emergent Fabula.

IMPORTANT: When creating chronicle events, use the persona context above to properly identify who is who. Do not refer to characters generically as "the user" or "the character" when you have specific persona information available. Use actual character names in all fields.

**CRITICAL REMINDERS:**
1. **DEDUPLICATION FIRST**: Before writing any event, verify it's not already covered in the chronicle context above
2. **QUALITY OVER QUANTITY**: One amazing, unique event is better than three redundant ones
3. **EPIC STORYTELLING**: Every summary should make the reader desperately want to know what happens next
4. **NEW NARRATIVE VALUE**: Only chronicle what advances the story beyond what's already been captured

**JSON FORMAT REQUIREMENTS:**
- Ensure all string values are properly quoted and escaped
- Use double quotes (") for JSON strings, not single quotes (')  
- Escape any quotes within string values with \"
- Avoid unescaped newlines or special characters in strings
- Ensure all arrays and objects are properly closed with ] and }}"#,
            persona_section,
            triage_result.event_type,
            triage_result.summary,
            triage_result.confidence,
            serde_json::to_string_pretty(knowledge_context).unwrap_or_default(),
            tools_description,
            chronicle_id.map(|id| id.to_string()).unwrap_or_else(|| "None".to_string()),
            chronicle_was_just_created,
            if chronicle_was_just_created {
                "IMPORTANT: A new chronicle was JUST created for this significant event. You MUST create at least one chronicle_event to record this founding moment that triggered the chronicle's creation. This is the FIRST event in a new chronicle!"
            } else {
                ""
            }
        );

        let response = self.call_ai_structured(&self.config.planning_model, &planning_prompt).await?;

        let reasoning = response.get("reasoning")
            .and_then(|v| v.as_str())
            .unwrap_or("No reasoning provided")
            .to_string();

        let actions = response.get("actions")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|action| {
                        let tool_name = action.get("tool_name")?.as_str()?.to_string();
                        let parameters = action.get("parameters")?.clone();
                        let action_reasoning = action.get("reasoning")
                            .and_then(|v| v.as_str())
                            .unwrap_or("No reasoning")
                            .to_string();

                        Some(PlannedAction {
                            tool_name,
                            parameters,
                            reasoning: action_reasoning,
                        })
                    })
                    .collect()
            })
            .unwrap_or_default();

        Ok(ActionPlan { reasoning, actions })
    }

    /// Step 4: Execute the planned actions
    async fn execute_action_plan(
        &self,
        plan: &ActionPlan,
        user_id: Uuid,
        chronicle_id: Option<Uuid>,
        session_dek: &SessionDek,
        _persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<Vec<ToolResult>, AppError> {
        info!("Executing action plan with {} actions", plan.actions.len());

        // Chronicle should already be created at workflow level if needed

        let mut results = Vec::new();

        for (index, action) in plan.actions.iter().enumerate() {
            if index >= self.config.max_tool_executions {
                warn!("Reached maximum tool execution limit ({})", self.config.max_tool_executions);
                break;
            }

            debug!("Executing action {}: {} - {}", index + 1, action.tool_name, action.reasoning);

            match self.tool_registry.get_tool(&action.tool_name) {
                Ok(tool) => {
                    // Inject required context parameters into tool calls
                    let mut enriched_parameters = action.parameters.clone();
                    
                    // Add user_id, chronicle_id, and session_dek for tools that need them
                    if action.tool_name == "create_chronicle_event" || action.tool_name == "create_lorebook_entry" {
                        if let serde_json::Value::Object(ref mut obj) = enriched_parameters {
                            // Add user_id if not present
                            if !obj.contains_key("user_id") {
                                obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            }
                            
                            // Add chronicle_id if not present and available (for chronicle events)
                            if action.tool_name == "create_chronicle_event" && !obj.contains_key("chronicle_id") {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            // Add session_dek for both lorebook and chronicle event creation (encryption required!)
                            if (action.tool_name == "create_lorebook_entry" || action.tool_name == "create_chronicle_event") && !obj.contains_key("session_dek") {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                        } else {
                            // If parameters is not an object, create one with required fields
                            let mut obj = serde_json::Map::new();
                            obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            
                            if action.tool_name == "create_chronicle_event" {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            if action.tool_name == "create_lorebook_entry" || action.tool_name == "create_chronicle_event" {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                            
                            // Merge with existing parameters if they were in a different format
                            if let Ok(existing_obj) = serde_json::from_value::<serde_json::Map<String, serde_json::Value>>(action.parameters.clone()) {
                                obj.extend(existing_obj);
                            }
                            enriched_parameters = serde_json::Value::Object(obj);
                        }
                    }
                    
                    debug!("Executing {} tool with enriched params: {}", action.tool_name, serde_json::to_string(&enriched_parameters).unwrap_or_default());
                    
                    match tool.execute(&enriched_parameters).await {
                        Ok(result) => {
                            info!("Successfully executed tool: {}", action.tool_name);
                            results.push(result);
                        }
                        Err(e) => {
                            error!("Tool execution failed for {}: {}", action.tool_name, e);
                            // Continue with other actions even if one fails
                            results.push(json!({
                                "success": false,
                                "error": e.to_string(),
                                "tool": action.tool_name
                            }));
                        }
                    }
                }
                Err(e) => {
                    error!("Tool not found: {} - {}", action.tool_name, e);
                    results.push(json!({
                        "success": false,
                        "error": format!("Tool not found: {}", action.tool_name)
                    }));
                }
            }
        }

        Ok(results)
    }

    /// Helper: Sanitize HTML entities from text content
    fn sanitize_html_entities(text: &str) -> String {
        text.replace("&amp;", "&")
            .replace("&lt;", "<")
            .replace("&gt;", ">")
            .replace("&quot;", "\"")
            .replace("&apos;", "'")
            .replace("&#39;", "'")
            .replace("&#x27;", "'")
    }

    /// Helper: Build conversation text from messages with token-based limiting
    async fn build_conversation_text(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<String, AppError> {
        let mut conversation = String::new();
        let mut used_tokens = 0;
        
        // Token budget for conversation context - use a much larger budget to ensure
        // the AI has sufficient recent context to understand current story state.
        // Flash-lite model is very cheap ($0.10 per 1M tokens) so we can afford more context.
        let token_budget = 50000; // Allow ~50,000 tokens for conversation context (25x increase)
        
        // Process messages in reverse order (newest first) to prioritize recent context
        let mut selected_messages = Vec::new();
        
        for message in messages.iter().rev() {
            let role = match message.message_type {
                crate::models::chats::MessageRole::User => "User",
                crate::models::chats::MessageRole::Assistant => "Assistant",
                crate::models::chats::MessageRole::System => "System",
            };

            let content = message.decrypt_content_field(&session_dek.0)
                .unwrap_or_else(|e| {
                    warn!("Failed to decrypt message {}: {}", message.id, e);
                    "[Failed to decrypt message]".to_string()
                });

            // Sanitize HTML entities from the content before formatting
            let sanitized_content = Self::sanitize_html_entities(&content);

            // Format the message and estimate its token count
            let formatted_message = format!("\n{}: {}\n", role, sanitized_content);
            
            // Estimate tokens for this message
            let message_tokens = match self.token_counter
                .count_tokens(&formatted_message, CountingMode::LocalOnly, Some(&self.config.triage_model))
                .await
            {
                Ok(estimate) => estimate.total,
                Err(e) => {
                    warn!("Failed to count tokens for message, using character estimate: {}", e);
                    // Fallback: rough character-based estimate (4 chars per token)
                    formatted_message.len() / 4
                }
            };
            
            // Check if we can fit this message in the budget
            if selected_messages.is_empty() || used_tokens + message_tokens <= token_budget {
                used_tokens += message_tokens;
                selected_messages.push(formatted_message);
                
                debug!(
                    message_tokens,
                    used_tokens,
                    token_budget,
                    role,
                    "Selected message for conversation context"
                );
            } else {
                debug!(
                    message_tokens,
                    used_tokens,
                    token_budget,
                    "Skipping message due to token budget limit"
                );
                break; // Stop processing once we hit the budget limit
            }
        }
        
        // Reverse the selected messages to restore chronological order
        selected_messages.reverse();
        let selected_count = selected_messages.len();
        
        // Build the final conversation string
        for message in selected_messages {
            conversation.push_str(&message);
        }
        
        debug!(
            total_messages = messages.len(),
            selected_count,
            used_tokens,
            token_budget,
            "Built conversation context with token-based limiting"
        );

        Ok(conversation)
    }

    /// Generate a meaningful chronicle name based on chat messages  
    async fn generate_chronicle_name_from_messages(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<String, AppError> {
        // Build a sample of the conversation for analysis
        let conversation_sample = self.build_conversation_text(messages, session_dek).await?;
        
        // Use AI to generate a meaningful chronicle name based on the conversation
        let name_prompt = format!(
            r#"Based on this roleplay conversation, generate a short, descriptive chronicle name (max 60 characters).
Focus on the main characters, setting, or central theme. Make it engaging and specific.

Examples of good names:
- "Thorin's Quest for Erebor"
- "The Dragon's Last Stand" 
- "Adventures in the Feywild"
- "Detective Sarah's Case Files"

Conversation:
{}

Respond with ONLY the chronicle name, no quotes or explanation:"#,
            conversation_sample.chars().take(2000).collect::<String>()
        );

        match self.call_ai_for_simple_task(&name_prompt).await {
            Ok(generated_name) => {
                let clean_name = generated_name.trim().trim_matches('"').trim_matches('\'');
                if clean_name.len() > 3 && clean_name.len() <= 60 {
                    Ok(clean_name.to_string())
                } else {
                    // Fallback if AI generated something weird
                    Ok(format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M")))
                }
            },
            Err(_) => {
                // Fallback if AI call fails
                Ok(format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M")))
            }
        }
    }

    /// Generate a meaningful chronicle name based on the planned actions
    fn generate_chronicle_name(&self, actions: &[PlannedAction]) -> String {
        // Look for chronicle events and extract meaningful subjects/themes
        let mut subjects = Vec::new();
        let mut event_types = Vec::new();
        
        for action in actions {
            if action.tool_name == "create_chronicle_event" {
                // Try to extract subject and event type from parameters
                if let Some(subject) = action.parameters.get("subject").and_then(|v| v.as_str()) {
                    if !subjects.contains(&subject.to_string()) {
                        subjects.push(subject.to_string());
                    }
                }
                
                if let Some(event_subtype) = action.parameters.get("event_subtype").and_then(|v| v.as_str()) {
                    if !event_types.contains(&event_subtype.to_string()) {
                        event_types.push(event_subtype.to_string());
                    }
                }
            }
        }
        
        // Generate name based on content
        if !subjects.is_empty() {
            let primary_subject = &subjects[0];
            
            if !event_types.is_empty() {
                let primary_event = &event_types[0];
                // Convert event type to readable format
                let readable_event = primary_event
                    .replace("_", " ")
                    .to_lowercase();
                
                if subjects.len() == 1 {
                    format!("{}: {}", primary_subject, readable_event)
                } else {
                    format!("{} & {} others: {}", primary_subject, subjects.len() - 1, readable_event)
                }
            } else {
                if subjects.len() == 1 {
                    format!("{}'s Chronicle", primary_subject)
                } else {
                    format!("{} & {} others", primary_subject, subjects.len() - 1)
                }
            }
        } else if !event_types.is_empty() {
            let primary_event = &event_types[0];
            let readable_event = primary_event
                .replace("_", " ")
                .to_lowercase();
            
            if event_types.len() == 1 {
                format!("Chronicle of {}", readable_event)
            } else {
                format!("Chronicle of {} & more", readable_event)
            }
        } else {
            // Fallback with timestamp to ensure uniqueness
            format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M"))
        }
    }
    
    /// Helper method to call AI for simple text generation tasks
    async fn call_ai_for_simple_task(&self, prompt: &str) -> Result<String, AppError> {
        use genai::chat::{
            ChatOptions as GenAiChatOptions, ChatRole, MessageContent, ChatMessage as GenAiChatMessage
        };
        
        let user_message = GenAiChatMessage {
            role: ChatRole::User,
            content: MessageContent::Text(prompt.to_string()),
            options: None,
        };

        let mut genai_chat_options = GenAiChatOptions::default();
        genai_chat_options = genai_chat_options.with_temperature(0.7); // Creative but focused
        genai_chat_options = genai_chat_options.with_max_tokens(100); // Short response
        
        let system_prompt = "You are a creative assistant that generates engaging, concise chronicle names for roleplay stories.";
        let chat_req = genai::chat::ChatRequest::new(vec![user_message]).with_system(system_prompt);
        
        let response = self.ai_client
            .exec_chat("gemini-2.5-flash-lite-preview-06-17", chat_req, Some(genai_chat_options))
            .await
            .map_err(|e| AppError::LlmClientError(format!("AI call failed: {}", e)))?;

        Ok(response.first_content_text_as_str().unwrap_or_default().to_string())
    }

    /// Helper: Get comprehensive chronicle context with XML labeling for deduplication
    /// 
    /// This replaces the temporal filtering approach. Instead of hiding chronicle events,
    /// we show ALL relevant chronicles but clearly label them as existing events that 
    /// should NOT be duplicated. This allows the AI to see the full context while
    /// preventing redundant chronicle creation.
    async fn get_recent_chronicle_context_with_xml_labeling(
        &self,
        _user_id: Uuid,
        chronicle_id: Uuid,
    ) -> Result<String, AppError> {
        let search_tool = self.tool_registry.get_tool("search_knowledge_base")
            .map_err(|e| AppError::InternalServerErrorGeneric(format!("Search tool not available: {}", e)))?;

        let mut context_sections = Vec::new();
        
        // Get recent chronicle events (no temporal exclusion - show everything)
        let recent_params = json!({
            "query": "chronicle events",
            "search_type": "chronicles",
            "limit": 50,
            "chronicle_filter": chronicle_id.to_string(),
            "sort": "temporal_desc" // Most recent first by timestamp
        });

        if let Ok(recent_results) = search_tool.execute(&recent_params).await {
            if let Some(events) = recent_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut recent_context = String::new();
                    recent_context.push_str("RECENT CHRONICLE EVENTS (Most Recent First):\n");
                    
                    for (i, event) in events.iter().take(30).enumerate() {
                        if let (Some(summary), Some(event_type), Some(timestamp)) = (
                            event.get("content").and_then(|c| c.as_str()),
                            event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str()),
                            event.get("metadata").and_then(|m| m.get("timestamp")).and_then(|t| t.as_str())
                        ) {
                            recent_context.push_str(&format!(
                                "{:2}. [{:10}] {:20} | {}\n", 
                                i + 1,
                                timestamp.split('T').next().unwrap_or("unknown"),
                                format!("[{}]", event_type),
                                summary.chars().take(95).collect::<String>()
                            ));
                        }
                    }
                    context_sections.push(recent_context);
                }
            }
        }

        // Get causally related events
        let causal_params = json!({
            "query": "causal relationships",
            "search_type": "chronicles",
            "limit": 20,
            "chronicle_filter": chronicle_id.to_string(),
            "graph_traversal": "causal_chains"
        });

        if let Ok(causal_results) = search_tool.execute(&causal_params).await {
            if let Some(events) = causal_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut causal_context = String::new();
                    causal_context.push_str("\nCAUSALLY RELATED EVENTS:\n");
                    
                    for (i, event) in events.iter().take(15).enumerate() {
                        if let (Some(summary), Some(event_type)) = (
                            event.get("content").and_then(|c| c.as_str()),
                            event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str())
                        ) {
                            causal_context.push_str(&format!(
                                "{:2}. {:20} → {}\n", 
                                i + 1,
                                format!("[{}]", event_type),
                                summary.chars().take(85).collect::<String>()
                            ));
                        }
                    }
                    context_sections.push(causal_context);
                }
            }
        }

        // Assemble the context with clear XML labeling
        if context_sections.is_empty() {
            Ok("NO EXISTING CHRONICLES FOUND - This appears to be a new chronicle.".to_string())
        } else {
            Ok(context_sections.join("\n"))
        }
    }
    

    /// Helper: Make a structured AI call with JSON schema
    async fn call_ai_structured(
        &self,
        model: &str,
        prompt: &str,
    ) -> Result<Value, AppError> {
        use genai::chat::{
            ChatOptions as GenAiChatOptions, HarmBlockThreshold, HarmCategory, SafetySetting,
            ChatRole, MessageContent, ChatMessage as GenAiChatMessage
        };
        
        debug!("Making structured AI call to model: {}", model);
        
        // Create the user message
        let user_message = GenAiChatMessage {
            role: ChatRole::User,
            content: MessageContent::Text(prompt.to_string()),
            options: None,
        };

        // Build chat options for the AI call
        let mut genai_chat_options = GenAiChatOptions::default();
        
        // Set temperature for structured analysis (higher for planning, lower for triage)
        let temperature = if model.contains("pro") { 0.5 } else { 0.3 };
        genai_chat_options = genai_chat_options.with_temperature(temperature);
        
        // Set max tokens (increased for richer narrative content)
        genai_chat_options = genai_chat_options.with_max_tokens(16384);
        
        // Add safety settings to allow analysis of any content
        let safety_settings = vec![
            SafetySetting::new(HarmCategory::Harassment, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::HateSpeech, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::SexuallyExplicit, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::DangerousContent, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::CivicIntegrity, HarmBlockThreshold::BlockNone),
        ];
        genai_chat_options = genai_chat_options.with_safety_settings(safety_settings);

        // Create system prompt for narrative analysis
        let system_prompt = "You are a narrative intelligence agent that analyzes roleplay conversations and manages story memory. You provide structured JSON responses following the exact schema requested.";

        // Create chat request
        let chat_req = genai::chat::ChatRequest::new(vec![user_message]).with_system(system_prompt);
        
        info!("Making AI call for narrative analysis with model: {}", model);
        
        // Call the AI client
        let response = self.ai_client
            .exec_chat(model, chat_req, Some(genai_chat_options))
            .await
            .map_err(|e| {
                error!("AI client call failed during narrative analysis: {}", e);
                AppError::LlmClientError(format!("Narrative analysis failed: {e}"))
            })?;

        info!("AI client call successful, processing response...");

        // Process the response to extract JSON value
        self.process_structured_response(response)
    }

    /// Process structured chat response to extract JSON value
    fn process_structured_response(
        &self,
        response: genai::chat::ChatResponse,
    ) -> Result<Value, AppError> {
        // Extract the first content as text
        let content = response.first_content_text_as_str().unwrap_or_default();
        info!("Processing structured response, content length: {} characters", content.len());
        
        // The response might be wrapped in markdown or be raw JSON
        let cleaned_content = if content.trim().starts_with("```json") {
            // Extract content between ```json and closing ```
            let start_marker = "```json";
            if let Some(start_pos) = content.find(start_marker) {
                let start = start_pos + start_marker.len();
                // Find closing ``` after the opening marker
                if let Some(end_pos) = content[start..].find("```") {
                    let end = start + end_pos;
                    if end > start {
                        content[start..end].trim()
                    } else {
                        content.trim()
                    }
                } else {
                    // No closing ```, take everything after ```json
                    content[start..].trim()
                }
            } else {
                content.trim()
            }
        } else if content.trim().starts_with("```") {
            // Extract content between ``` and closing ```
            let start_marker = "```";
            if let Some(start_pos) = content.find(start_marker) {
                let start = start_pos + start_marker.len();
                // Find closing ``` after the opening marker
                if let Some(end_pos) = content[start..].find("```") {
                    let end = start + end_pos;
                    if end > start {
                        content[start..end].trim()
                    } else {
                        content.trim()
                    }
                } else {
                    // No closing ```, take everything after ```
                    content[start..].trim()
                }
            } else {
                content.trim()
            }
        } else {
            content.trim()
        };

        // Try to parse as JSON first
        match serde_json::from_str(cleaned_content) {
            Ok(value) => Ok(value),
            Err(e) => {
                error!("Failed to parse structured response as JSON: {}", e);
                error!("Raw response content (first 500 chars): {}", &content[..content.len().min(500)]);
                error!("Cleaned content (first 500 chars): {}", &cleaned_content[..cleaned_content.len().min(500)]);
                
                // Log the problematic line and column
                let line = e.line();
                let column = e.column();
                let lines: Vec<&str> = cleaned_content.lines().collect();
                if let Some(error_line) = lines.get(line.saturating_sub(1)) {
                    error!("Error at line {}, column {}: '{}'", line, column, error_line);
                    error!("Character at error position: '{}'", 
                        error_line.chars().nth(column.saturating_sub(1)).unwrap_or(' '));
                }

                // Attempt to fix common JSON issues and retry parsing
                info!("Attempting JSON repair and retry...");
                let repaired_json = self.repair_json_string(cleaned_content);
                
                match serde_json::from_str(&repaired_json) {
                    Ok(value) => {
                        warn!("Successfully parsed JSON after repair");
                        return Ok(value);
                    }
                    Err(repair_error) => {
                        error!("JSON repair attempt failed: {}", repair_error);
                        error!("Repaired content (first 500 chars): {}", &repaired_json[..repaired_json.len().min(500)]);
                    }
                }

                // Try to find JSON object boundaries and recover as last resort
                if let Some(start_brace) = cleaned_content.find('{') {
                    if let Some(end_brace) = cleaned_content.rfind('}') {
                        if end_brace > start_brace {
                            let potential_json = &cleaned_content[start_brace..=end_brace];
                            let repaired_potential = self.repair_json_string(potential_json);
                            match serde_json::from_str(&repaired_potential) {
                                Ok(value) => {
                                    warn!("Successfully recovered JSON after boundary extraction and repair");
                                    return Ok(value);
                                }
                                Err(_) => {
                                    error!("Final JSON recovery attempt also failed");
                                }
                            }
                        }
                    }
                }
                
                Err(AppError::InternalServerErrorGeneric(format!("Failed to parse structured response: {}", e)))
            }
        }
    }

    /// Repair common JSON formatting issues, particularly unescaped quotes in string values
    fn repair_json_string(&self, json_str: &str) -> String {
        // Common repair strategies for AI-generated JSON
        let mut repaired = json_str.to_string();
        
        // Strategy 1: Fix unescaped quotes within string values
        // This is the most common issue where AI generates: "reasoning": "He said "hello" to me"
        // We need to escape quotes that are inside string values but not the ones that are JSON delimiters
        repaired = self.fix_unescaped_quotes_in_strings(&repaired);
        
        // Strategy 2: Remove any trailing commas before closing braces/brackets
        repaired = regex::Regex::new(r",(\s*[}\]])").unwrap()
            .replace_all(&repaired, "$1")
            .to_string();
        
        // Strategy 3: Fix common newline and special character issues within strings
        // Note: Only escape these characters if they're actually inside JSON string values
        // For now, skip this strategy as it can break valid JSON formatting
        
        // Strategy 4: Ensure proper boolean/null values (case sensitive)
        repaired = regex::Regex::new(r":\s*(True|TRUE)\b").unwrap()
            .replace_all(&repaired, ": true")
            .to_string();
        repaired = regex::Regex::new(r":\s*(False|FALSE)\b").unwrap()
            .replace_all(&repaired, ": false")
            .to_string();
        repaired = regex::Regex::new(r":\s*(None|NULL)\b").unwrap()
            .replace_all(&repaired, ": null")
            .to_string();
        
        // Strategy 5: Fix common incomplete structures
        // Fix missing quotes around unquoted string values
        repaired = regex::Regex::new(r#":\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([,}\]])"#).unwrap()
            .replace_all(&repaired, r#": "$1"$2"#)
            .to_string();
        
        // Strategy 6: Ensure arrays and objects are properly closed
        // Count opening and closing braces/brackets and add missing ones if needed
        let open_braces = repaired.chars().filter(|&c| c == '{').count();
        let close_braces = repaired.chars().filter(|&c| c == '}').count();
        let open_brackets = repaired.chars().filter(|&c| c == '[').count();
        let close_brackets = repaired.chars().filter(|&c| c == ']').count();
        
        // Add missing closing braces
        for _ in 0..(open_braces.saturating_sub(close_braces)) {
            repaired.push('}');
        }
        
        // Add missing closing brackets  
        for _ in 0..(open_brackets.saturating_sub(close_brackets)) {
            repaired.push(']');
        }
        
        repaired
    }
    
    /// Fix unescaped quotes within JSON string values
    fn fix_unescaped_quotes_in_strings(&self, json_str: &str) -> String {
        let mut result = String::with_capacity(json_str.len() * 2);
        let mut chars = json_str.chars().peekable();
        let mut in_string = false;
        let mut escape_next = false;
        
        while let Some(ch) = chars.next() {
            match ch {
                '"' if !escape_next => {
                    // This is either starting/ending a string or an unescaped quote inside a string
                    if in_string {
                        // Check if this is really the end of the string by looking ahead
                        // Skip whitespace and see if we find a colon, comma, or closing brace/bracket
                        let mut lookahead = chars.clone();
                        let mut found_whitespace_only = true;
                        
                        while let Some(&next_ch) = lookahead.peek() {
                            if next_ch.is_whitespace() {
                                lookahead.next();
                            } else {
                                found_whitespace_only = false;
                                break;
                            }
                        }
                        
                        if let Some(&next_non_ws) = lookahead.peek() {
                            if matches!(next_non_ws, ':' | ',' | '}' | ']') || found_whitespace_only {
                                // This is likely the end of the string
                                in_string = false;
                                result.push('"');
                            } else {
                                // This is likely an unescaped quote inside the string
                                result.push_str("\\\"");
                            }
                        } else {
                            // End of input, probably end of string
                            in_string = false;
                            result.push('"');
                        }
                    } else {
                        // Starting a new string
                        in_string = true;
                        result.push('"');
                    }
                }
                '\\' if !escape_next => {
                    escape_next = true;
                    result.push('\\');
                }
                _ => {
                    escape_next = false;
                    result.push(ch);
                }
            }
        }
        
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::chats::{ChatMessage, MessageRole};
    use crate::crypto::{encrypt_gcm, generate_dek};
    use chrono::{Utc, Duration};
    
    // Helper struct to test JSON repair functions without full runner setup
    struct JsonRepairer;
    
    impl JsonRepairer {
        fn repair_json_string(&self, json_str: &str) -> String {
            // Common repair strategies for AI-generated JSON
            let mut repaired = json_str.to_string();
            
            // Strategy 1: Fix unescaped quotes within string values
            repaired = self.fix_unescaped_quotes_in_strings(&repaired);
            
            // Strategy 2: Remove any trailing commas before closing braces/brackets
            repaired = regex::Regex::new(r",(\s*[}\]])").unwrap()
                .replace_all(&repaired, "$1")
                .to_string();
            
            // Strategy 3: Fix common newline issues within strings (skipped in this implementation)
            
            // Strategy 4: Ensure proper boolean/null values (case sensitive)
            repaired = regex::Regex::new(r":\s*(True|TRUE)\b").unwrap()
                .replace_all(&repaired, ": true")
                .to_string();
            repaired = regex::Regex::new(r":\s*(False|FALSE)\b").unwrap()
                .replace_all(&repaired, ": false")
                .to_string();
            repaired = regex::Regex::new(r":\s*(None|NULL)\b").unwrap()
                .replace_all(&repaired, ": null")
                .to_string();
            
            repaired
        }
        
        fn fix_unescaped_quotes_in_strings(&self, json_str: &str) -> String {
            let mut result = String::with_capacity(json_str.len() * 2);
            let mut chars = json_str.chars().peekable();
            let mut in_string = false;
            let mut escape_next = false;
            
            while let Some(ch) = chars.next() {
                match ch {
                    '"' if !escape_next => {
                        // This is either starting/ending a string or an unescaped quote inside a string
                        if in_string {
                            // Check if this is really the end of the string by looking ahead
                            // Skip whitespace and see if we find a colon, comma, or closing brace/bracket
                            let mut lookahead = chars.clone();
                            let mut found_whitespace_only = true;
                            
                            while let Some(&next_ch) = lookahead.peek() {
                                if next_ch.is_whitespace() {
                                    lookahead.next();
                                } else {
                                    found_whitespace_only = false;
                                    break;
                                }
                            }
                            
                            if let Some(&next_non_ws) = lookahead.peek() {
                                if matches!(next_non_ws, ':' | ',' | '}' | ']') || found_whitespace_only {
                                    // This is likely the end of the string
                                    in_string = false;
                                    result.push('"');
                                } else {
                                    // This is likely an unescaped quote inside the string
                                    result.push_str("\\\"");
                                }
                            } else {
                                // End of input, probably end of string
                                in_string = false;
                                result.push('"');
                            }
                        } else {
                            // Starting a new string
                            in_string = true;
                            result.push('"');
                        }
                    }
                    '\\' if !escape_next => {
                        escape_next = true;
                        result.push('\\');
                    }
                    _ => {
                        escape_next = false;
                        result.push(ch);
                    }
                }
            }
            
            result
        }
    }
    
    #[test]
    fn test_json_repair_unescaped_quotes() {
        let repairer = JsonRepairer;
        
        // Test case 1: Unescaped quotes in reasoning field
        let broken_json = r#"{
    "reasoning": "He said "hello" to me and I responded",
    "actions": []
}"#;
        
        println!("Original broken JSON:\n{}", broken_json);
        let repaired = repairer.repair_json_string(broken_json);
        println!("Repaired JSON:\n{}", repaired);
        
        let parsed: Result<Value, _> = serde_json::from_str(&repaired);
        match &parsed {
            Ok(value) => println!("Successfully parsed: {:?}", value),
            Err(e) => println!("Parse error: {}", e),
        }
        assert!(parsed.is_ok(), "Failed to parse repaired JSON: {}", repaired);
        
        // Test case 2: Multiple unescaped quotes
        let broken_json2 = r#"{
    "reasoning": "The character "John" told "Mary" about the "secret"",
    "actions": []
}"#;
        
        let repaired2 = repairer.repair_json_string(broken_json2);
        let parsed2: Result<Value, _> = serde_json::from_str(&repaired2);
        assert!(parsed2.is_ok(), "Failed to parse repaired JSON with multiple quotes: {}", repaired2);
        
        // Test case 3: Mixed issues (trailing comma + unescaped quotes)
        let broken_json3 = r#"{
    "reasoning": "She said "no" but meant "yes"",
    "actions": [],
}"#;
        
        let repaired3 = repairer.repair_json_string(broken_json3);
        let parsed3: Result<Value, _> = serde_json::from_str(&repaired3);
        assert!(parsed3.is_ok(), "Failed to parse repaired JSON with mixed issues: {}", repaired3);
        
        // Test case 4: Already valid JSON should remain unchanged
        let valid_json = r#"{
    "reasoning": "This is properly escaped \"quote\" content",
    "actions": []
}"#;
        
        let repaired4 = repairer.repair_json_string(valid_json);
        let parsed4: Result<Value, _> = serde_json::from_str(&repaired4);
        assert!(parsed4.is_ok(), "Failed to parse already valid JSON: {}", repaired4);
    }
    
    #[test]
    fn test_calculate_conversation_timespan_empty_messages() {
        // Create a mock agent runner (we only need the method, not full setup)
        let config = NarrativeWorkflowConfig::default();
        // We can't easily construct a full NarrativeAgentRunner for tests without mocking
        // so we'll test the logic manually
        
        let messages: Vec<ChatMessage> = vec![];
        
        // Simulate the logic from calculate_conversation_timespan
        let now = Utc::now();
        let (start_time, duration) = if messages.is_empty() {
            (now, Duration::hours(1))
        } else {
            (now, Duration::minutes(30))
        };
        
        assert_eq!(duration, Duration::hours(1), "Empty messages should default to 1-hour window");
    }
    
    #[test]
    fn test_calculate_conversation_timespan_single_message() {
        let now = Utc::now();
        let message = create_test_message(now, "Test message");
        let messages = vec![message];
        
        // Simulate the logic
        let mut earliest = Utc::now();
        let mut latest = chrono::DateTime::<chrono::Utc>::MIN_UTC;
        
        for message in &messages {
            if message.created_at < earliest {
                earliest = message.created_at;
            }
            if message.created_at > latest {
                latest = message.created_at;
            }
        }
        
        let duration = latest.signed_duration_since(earliest)
            .max(Duration::minutes(30));
        
        assert_eq!(duration, Duration::minutes(30), "Single message should use minimum 30-minute window");
    }
    
    #[test]
    fn test_calculate_conversation_timespan_multiple_messages() {
        let now = Utc::now();
        let messages = vec![
            create_test_message(now - Duration::hours(2), "First message"),
            create_test_message(now - Duration::hours(1), "Second message"),  
            create_test_message(now, "Latest message"),
        ];
        
        // Simulate the logic
        let mut earliest = Utc::now();
        let mut latest = chrono::DateTime::<chrono::Utc>::MIN_UTC;
        
        for message in &messages {
            if message.created_at < earliest {
                earliest = message.created_at;
            }
            if message.created_at > latest {
                latest = message.created_at;
            }
        }
        
        let duration = latest.signed_duration_since(earliest)
            .max(Duration::minutes(30));
        
        assert_eq!(duration, Duration::hours(2), "Multiple messages should span the actual time range");
    }
    
    #[test] 
    fn test_temporal_exclusion_logic() {
        let now = Utc::now();
        let conversation_start = now - Duration::hours(1);
        let conversation_duration = Duration::hours(1);
        
        // Calculate exclusion cutoff (15 minutes before conversation start)
        let exclusion_cutoff = conversation_start - Duration::minutes(15);
        
        // Test that events created after the cutoff should be excluded
        let recent_event_time = conversation_start + Duration::minutes(30); // During conversation
        let old_event_time = conversation_start - Duration::hours(2); // Well before conversation
        
        assert!(recent_event_time > exclusion_cutoff, "Recent events should be after cutoff");
        assert!(old_event_time < exclusion_cutoff, "Old events should be before cutoff");
        
        // This logic simulates what would happen in the search filtering
        let should_exclude_recent = recent_event_time > exclusion_cutoff;
        let should_exclude_old = old_event_time > exclusion_cutoff;
        
        assert!(should_exclude_recent, "Recent events should be excluded");
        assert!(!should_exclude_old, "Old events should not be excluded");
    }
    
    // Helper function to create test messages with proper encryption
    fn create_test_message(created_at: chrono::DateTime<chrono::Utc>, content: &str) -> ChatMessage {
        // Generate a test DEK for encryption
        let test_dek = generate_dek().expect("Failed to generate test DEK");
        
        // Encrypt the content
        let (encrypted_content, content_nonce) = encrypt_gcm(
            content.as_bytes(),
            &test_dek
        ).expect("Failed to encrypt test content");
        
        ChatMessage {
            id: Uuid::new_v4(),
            session_id: Uuid::new_v4(),
            user_id: Uuid::new_v4(),
            message_type: MessageRole::User,
            content: encrypted_content,
            content_nonce: Some(content_nonce),
            created_at,
            prompt_tokens: None,
            completion_tokens: None,
            raw_prompt_ciphertext: None,
            raw_prompt_nonce: None,
            model_name: "test-model".to_string(),
        }
    }
    
    #[test]
    fn test_fix_unescaped_quotes_in_strings() {
        let repairer = JsonRepairer;
        
        // Test basic unescaped quote
        let input = r#""He said "hello" to me""#;
        let expected = r#""He said \"hello\" to me""#;
        let result = repairer.fix_unescaped_quotes_in_strings(input);
        assert_eq!(result, expected);
        
        // Test multiple quotes
        let input2 = r#""The "big" "red" "apple"""#;
        let expected2 = r#""The \"big\" \"red\" \"apple\"""#;
        let result2 = repairer.fix_unescaped_quotes_in_strings(input2);
        assert_eq!(result2, expected2);
        
        // Test quotes at the end
        let input3 = r#""She said "yes"""#;
        let expected3 = r#""She said \"yes\"""#;
        let result3 = repairer.fix_unescaped_quotes_in_strings(input3);
        assert_eq!(result3, expected3);
    }
    
    #[test]
    fn test_exclusion_cutoff_calculation() {
        let conversation_start = Utc::now() - Duration::hours(2);
        let conversation_duration = Duration::hours(1);
        
        // This matches the logic in get_recent_chronicle_context
        let exclusion_cutoff = conversation_start - Duration::minutes(15);
        
        // Verify the cutoff is 15 minutes before conversation start
        let expected_cutoff = conversation_start - Duration::minutes(15);
        assert_eq!(exclusion_cutoff, expected_cutoff);
        
        // Verify the temporal logic for filtering
        let event_during_conversation = conversation_start + Duration::minutes(30);
        let event_just_before_conversation = conversation_start - Duration::minutes(5);
        let event_well_before_conversation = conversation_start - Duration::hours(1);
        
        // Events during or just before conversation should be excluded
        assert!(event_during_conversation > exclusion_cutoff, "Events during conversation should be excluded");
        assert!(event_just_before_conversation > exclusion_cutoff, "Events just before conversation should be excluded");
        assert!(event_well_before_conversation < exclusion_cutoff, "Events well before conversation should be included");
    }
}

/// Result of the complete narrative workflow execution
#[derive(Debug)]
pub struct NarrativeWorkflowResult {
    pub triage_result: TriageResult,
    pub actions_taken: Vec<PlannedAction>,
    pub execution_results: Vec<ToolResult>,
    pub cost_estimate: f64,
}