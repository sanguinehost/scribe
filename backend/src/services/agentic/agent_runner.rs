//! Agent runner for executing the multi-step agentic narrative workflow.

use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{debug, error, info, warn};
use uuid::Uuid;
use secrecy::ExposeSecret;

use crate::{
    auth::session_dek::SessionDek,
    errors::AppError,
    llm::AiClient,
    models::chats::ChatMessage,
};

use super::{
    registry::ToolRegistry,
    tools::{ToolParams, ToolResult},
};

/// Configuration for the narrative intelligence workflow
#[derive(Debug, Clone)]
pub struct NarrativeWorkflowConfig {
    /// Model to use for triage analysis (should be fast and cheap)
    pub triage_model: String,
    /// Model to use for reasoning and planning (can be more capable)
    pub planning_model: String,
    /// Maximum number of tools that can be executed in a single workflow
    pub max_tool_executions: usize,
    /// Whether to enable cost-saving optimizations
    pub enable_cost_optimizations: bool,
}

impl Default for NarrativeWorkflowConfig {
    fn default() -> Self {
        Self {
            triage_model: "gemini-2.5-flash-lite-preview-06-17".to_string(),
            planning_model: "gemini-2.5-pro".to_string(),
            max_tool_executions: 5,
            enable_cost_optimizations: true,
        }
    }
}

/// Result of the triage analysis step
#[derive(Debug, Clone)]
pub struct TriageResult {
    pub is_significant: bool,
    pub summary: String,
    pub event_type: String,
    pub confidence: f32,
}

/// A plan of action generated by the AI agent
#[derive(Debug, Clone)]
pub struct ActionPlan {
    pub reasoning: String,
    pub actions: Vec<PlannedAction>,
}

/// A single action in the plan
#[derive(Debug, Clone)]
pub struct PlannedAction {
    pub tool_name: String,
    pub parameters: ToolParams,
    pub reasoning: String,
}

/// Core agent runner that orchestrates the narrative intelligence workflow
pub struct NarrativeAgentRunner {
    ai_client: Arc<dyn AiClient>,
    tool_registry: Arc<ToolRegistry>,
    config: NarrativeWorkflowConfig,
}

impl NarrativeAgentRunner {
    pub fn new(
        ai_client: Arc<dyn AiClient>,
        tool_registry: Arc<ToolRegistry>,
        config: NarrativeWorkflowConfig,
    ) -> Self {
        Self {
            ai_client,
            tool_registry,
            config,
        }
    }

    /// Execute the full narrative intelligence workflow for a set of chat messages
    pub async fn process_narrative_event(
        &self,
        user_id: Uuid,
        chat_session_id: Uuid,
        chronicle_id: Option<Uuid>,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<NarrativeWorkflowResult, AppError> {
        info!(
            "Starting narrative workflow for chat {} with {} messages",
            chat_session_id,
            messages.len()
        );

        // Step 1: Triage - Is this significant?
        let triage_result = self.perform_triage(messages, session_dek).await?;
        
        if !triage_result.is_significant {
            info!("Triage determined event is not significant, skipping workflow");
            return Ok(NarrativeWorkflowResult {
                triage_result,
                actions_taken: vec![],
                execution_results: vec![],
                cost_estimate: 0.0,
            });
        }

        info!("Event deemed significant: {}", triage_result.summary);

        // Step 2: Knowledge Retrieval - What do we already know?
        let knowledge_context = self.retrieve_knowledge_context(&triage_result).await?;

        // Step 3: Planning - What should we do?
        let action_plan = self.generate_action_plan(
            &triage_result,
            &knowledge_context,
            chronicle_id,
        ).await?;

        info!("Generated action plan with {} actions", action_plan.actions.len());

        // Step 4: Execution - Execute the planned actions
        let execution_results = self.execute_action_plan(&action_plan, user_id, chronicle_id, session_dek).await?;

        Ok(NarrativeWorkflowResult {
            triage_result,
            actions_taken: action_plan.actions,
            execution_results,
            cost_estimate: 0.0, // TODO: Implement cost tracking
        })
    }

    /// Step 1: Analyze if the conversation contains significant narrative events
    async fn perform_triage(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<TriageResult, AppError> {
        debug!("Performing narrative triage on {} messages", messages.len());

        // Build conversation text
        let conversation_text = self.build_conversation_text(messages, session_dek).await?;
        
        let triage_prompt = format!(
            r#"Analyze this roleplay conversation and determine if it contains narratively significant events.

CONVERSATION:
{}

You are analyzing according to the Ars Fabula narrative ontology. Respond with a JSON object:
{{
    "is_significant": boolean, // true if this contains events worth recording
    "summary": "string", // brief summary of what happened (if significant)
    "event_category": "string", // Primary narrative pillar: WORLD, CHARACTER, PLOT, RELATIONSHIP
    "event_type": "string", // Abstract category: DISCOVERY, ALTERATION, LORE_EXPANSION, STATE_CHANGE, DEVELOPMENT, PROGRESSION, REVELATION, TURNING_POINT, FORMATION, MODIFICATION, INTERACTION
    "narrative_action": "string", // Core verb: DISCOVERED, REVEALED, MET, ATTACKED, ACQUIRED, DIED, BETRAYED, TOLD, DECIDED, etc.
    "primary_agent": "string", // Name of entity initiating the action (if any)
    "primary_patient": "string", // Name of entity being acted upon (if any)
    "confidence": float // 0.0-1.0 confidence in this assessment
}}

SIGNIFICANCE CRITERIA (Ars Fabula Event Ontology):

WORLD Events (Changes to the physical/conceptual reality):
- DISCOVERY + DISCOVERED/FOUND: New locations, items, secrets, knowledge
- ALTERATION + TRANSFORMED/CHANGED: Environmental changes, world state shifts  
- LORE_EXPANSION + REVEALED/TOLD: Learning history, understanding mechanics

CHARACTER Events (Individual entity changes):
- STATE_CHANGE + DIED/TRANSFORMED: Death, injury, fundamental change
- DEVELOPMENT + ACQUIRED/EVOLVED: Skill gains, power increases, growth
- PROGRESSION + DECIDED/COMMITTED: Character arc advancement, goal changes

PLOT Events (Narrative structure progression):
- REVELATION + REVEALED/DISCOVERED: Secrets uncovered, mysteries solved
- TURNING_POINT + DECIDED/CHOSE: Critical decisions, plot branches
- PROGRESSION + ADVANCED/COMPLETED: Quest advancement, story milestone

RELATIONSHIP Events (Social dynamics):
- FORMATION + MET/BEFRIENDED: New relationships, alliances formed
- MODIFICATION + BETRAYED/CHANGED: Relationship shifts, trust changes
- INTERACTION + TOLD/ASKED: Significant dialogue, negotiations

Examples:
- Character death: WORLD.STATE_CHANGE + DIED, agent=killer, patient=victim
- Meeting someone: RELATIONSHIP.FORMATION + MET, agent=character1, patient=character2
- Finding treasure: WORLD.DISCOVERY + DISCOVERED, agent=finder, object=treasure
- Learning secret: PLOT.REVELATION + REVEALED, agent=revealer, patient=learner

Consider NOT significant:
- Routine conversation without impact
- Movement without discovery or consequence  
- Minor interactions without relationship change
- Repeated/redundant information"#,
            conversation_text
        );

        // Call AI for triage
        let response = self.call_ai_structured(&self.config.triage_model, &triage_prompt).await?;

        // Parse response
        let is_significant = response.get("is_significant")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        let summary = response.get("summary")
            .and_then(|v| v.as_str())
            .unwrap_or("No summary provided")
            .to_string();

        let event_type = response.get("event_type")
            .and_then(|v| v.as_str())
            .unwrap_or("UNKNOWN")
            .to_string();

        let confidence = response.get("confidence")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5) as f32;

        Ok(TriageResult {
            is_significant,
            summary,
            event_type,
            confidence,
        })
    }

    /// Step 2: Retrieve relevant knowledge from existing chronicles/lorebooks
    async fn retrieve_knowledge_context(
        &self,
        triage_result: &TriageResult,
    ) -> Result<Value, AppError> {
        debug!("Retrieving knowledge context for: {}", triage_result.summary);

        // Use the search tool to find relevant context
        let search_tool = self.tool_registry.get_tool("search_knowledge_base")
            .map_err(|e| AppError::InternalServerErrorGeneric(format!("Search tool not available: {}", e)))?;

        let search_params = json!({
            "query": triage_result.summary,
            "search_type": "all",
            "limit": 10
        });

        match search_tool.execute(&search_params).await {
            Ok(results) => Ok(results),
            Err(e) => {
                warn!("Knowledge search failed: {}", e);
                // Return empty context on failure
                Ok(json!({"results": []}))
            }
        }
    }

    /// Step 3: Generate an action plan based on the event and existing knowledge
    async fn generate_action_plan(
        &self,
        triage_result: &TriageResult,
        knowledge_context: &Value,
        chronicle_id: Option<Uuid>,
    ) -> Result<ActionPlan, AppError> {
        debug!("Generating action plan for event: {}", triage_result.event_type);

        // Dynamically build available tools list based on what's actually registered
        let available_tools = self.tool_registry.list_tools();
        let mut tools_description = String::new();
        
        for tool_name in &available_tools {
            match tool_name.as_str() {
                "create_chronicle_event" => {
                    tools_description.push_str("- create_chronicle_event: Record temporal, player-centric events that happened at specific times\n");
                }
                "create_lorebook_entry" => {
                    tools_description.push_str("- create_lorebook_entry: Create NEW lorebook entries for persistent world concepts (characters, locations, items, lore)\n");
                }
                "update_lorebook_entry" => {
                    tools_description.push_str("- update_lorebook_entry: Update existing lorebook entries when world state changes\n");
                }
                "search_knowledge_base" => {
                    tools_description.push_str("- search_knowledge_base: Find existing information (already done above)\n");
                }
                _ => {
                    // Skip other tools that aren't relevant for planning
                }
            }
        }

        let planning_prompt = format!(
            r#"You are an Ars Fabula narrative intelligence agent. Based on the event analysis, create a plan to update the narrative knowledge base.

EVENT ANALYSIS:
- Type: {}
- Summary: {}
- Confidence: {}

EXISTING KNOWLEDGE:
{}

AVAILABLE TOOLS:
{}

CHRONICLE ID: {}

Create a JSON plan following Ars Fabula principles:
{{
    "reasoning": "string explaining your logic and narrative impact",
    "actions": [
        {{
            "tool_name": "string",
            "parameters": {{}},
            "reasoning": "string explaining why this action advances the Fabula"
        }}
    ]
}}

ARS FABULA NARRATIVE ONTOLOGY RULES:

1. TEMPORAL EVENTS (for create_chronicle_event):
   - Use dot-notation event types: CATEGORY.TYPE.SUBTYPE
   - Include entity roles: subject (agent), object (patient), involved_entities
   - Add causality links when events are related
   - Include emotional/relational valence when relationships are affected
   - Examples:
     * Character death: "CHARACTER.STATE_CHANGE.DEATH" with subject=victim, object=killer
     * Discovery: "WORLD.DISCOVERY.LOCATION" with subject=discoverer, object=location
     * Betrayal: "RELATIONSHIP.MODIFICATION.NEGATIVE" with valence impacts

2. PERSISTENT CONCEPTS (for create_lorebook_entry):
   - Create entries for new entities (characters, locations, items, organizations)
   - Focus on timeless information and world-building
   - Use descriptive titles and comprehensive content
   - Include relevant keywords for retrieval

3. KNOWLEDGE INTEGRATION:
   - Review EXISTING KNOWLEDGE to avoid duplication
   - Link related events through causality
   - Update relationship states through valence
   - Maintain narrative coherence

4. TOOL PARAMETERS:
   - event_category: WORLD, CHARACTER, PLOT, RELATIONSHIP
   - event_type: DISCOVERY, ALTERATION, STATE_CHANGE, DEVELOPMENT, REVELATION, etc.
   - event_subtype: Specific classification (DEATH, LOCATION_DISCOVERY, SECRET_REVELATION, etc.)
   - subject: Primary agent/entity initiating action
   - object: Primary patient/entity being acted upon  
   - involved_entities: Other relevant participants
   - event_data: Context, location, emotional impacts. Use 'description' field for detailed narrative
   - summary: Brief overview (optional - can be auto-generated from event_data.description)

5. ONLY use tools listed in AVAILABLE TOOLS above
6. Prioritize narrative significance and causal coherence
7. Ensure events contribute meaningfully to the emergent Fabula"#,
            triage_result.event_type,
            triage_result.summary,
            triage_result.confidence,
            serde_json::to_string_pretty(knowledge_context).unwrap_or_default(),
            tools_description,
            chronicle_id.map(|id| id.to_string()).unwrap_or_else(|| "None".to_string())
        );

        let response = self.call_ai_structured(&self.config.planning_model, &planning_prompt).await?;

        let reasoning = response.get("reasoning")
            .and_then(|v| v.as_str())
            .unwrap_or("No reasoning provided")
            .to_string();

        let actions = response.get("actions")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|action| {
                        let tool_name = action.get("tool_name")?.as_str()?.to_string();
                        let parameters = action.get("parameters")?.clone();
                        let action_reasoning = action.get("reasoning")
                            .and_then(|v| v.as_str())
                            .unwrap_or("No reasoning")
                            .to_string();

                        Some(PlannedAction {
                            tool_name,
                            parameters,
                            reasoning: action_reasoning,
                        })
                    })
                    .collect()
            })
            .unwrap_or_default();

        Ok(ActionPlan { reasoning, actions })
    }

    /// Step 4: Execute the planned actions
    async fn execute_action_plan(
        &self,
        plan: &ActionPlan,
        user_id: Uuid,
        chronicle_id: Option<Uuid>,
        session_dek: &SessionDek,
    ) -> Result<Vec<ToolResult>, AppError> {
        info!("Executing action plan with {} actions", plan.actions.len());

        let mut results = Vec::new();

        for (index, action) in plan.actions.iter().enumerate() {
            if index >= self.config.max_tool_executions {
                warn!("Reached maximum tool execution limit ({})", self.config.max_tool_executions);
                break;
            }

            debug!("Executing action {}: {} - {}", index + 1, action.tool_name, action.reasoning);

            match self.tool_registry.get_tool(&action.tool_name) {
                Ok(tool) => {
                    // Inject required context parameters into tool calls
                    let mut enriched_parameters = action.parameters.clone();
                    
                    // Add user_id, chronicle_id, and session_dek for tools that need them
                    if action.tool_name == "create_chronicle_event" || action.tool_name == "create_lorebook_entry" {
                        if let serde_json::Value::Object(ref mut obj) = enriched_parameters {
                            // Add user_id if not present
                            if !obj.contains_key("user_id") {
                                obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            }
                            
                            // Add chronicle_id if not present and available (for chronicle events)
                            if action.tool_name == "create_chronicle_event" && !obj.contains_key("chronicle_id") {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            // Add session_dek for lorebook entry creation
                            if action.tool_name == "create_lorebook_entry" && !obj.contains_key("session_dek") {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                        } else {
                            // If parameters is not an object, create one with required fields
                            let mut obj = serde_json::Map::new();
                            obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            
                            if action.tool_name == "create_chronicle_event" {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            if action.tool_name == "create_lorebook_entry" {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                            
                            // Merge with existing parameters if they were in a different format
                            if let Ok(existing_obj) = serde_json::from_value::<serde_json::Map<String, serde_json::Value>>(action.parameters.clone()) {
                                obj.extend(existing_obj);
                            }
                            enriched_parameters = serde_json::Value::Object(obj);
                        }
                    }
                    
                    debug!("Executing {} tool with enriched params: {}", action.tool_name, serde_json::to_string(&enriched_parameters).unwrap_or_default());
                    
                    match tool.execute(&enriched_parameters).await {
                        Ok(result) => {
                            info!("Successfully executed tool: {}", action.tool_name);
                            results.push(result);
                        }
                        Err(e) => {
                            error!("Tool execution failed for {}: {}", action.tool_name, e);
                            // Continue with other actions even if one fails
                            results.push(json!({
                                "success": false,
                                "error": e.to_string(),
                                "tool": action.tool_name
                            }));
                        }
                    }
                }
                Err(e) => {
                    error!("Tool not found: {} - {}", action.tool_name, e);
                    results.push(json!({
                        "success": false,
                        "error": format!("Tool not found: {}", action.tool_name)
                    }));
                }
            }
        }

        Ok(results)
    }

    /// Helper: Build conversation text from messages
    async fn build_conversation_text(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<String, AppError> {
        let mut conversation = String::new();

        for message in messages.iter().take(10) { // Limit to last 10 messages for cost control
            let role = match message.message_type {
                crate::models::chats::MessageRole::User => "User",
                crate::models::chats::MessageRole::Assistant => "Assistant",
                crate::models::chats::MessageRole::System => "System",
            };

            let content = message.decrypt_content_field(&session_dek.0)
                .unwrap_or_else(|e| {
                    warn!("Failed to decrypt message {}: {}", message.id, e);
                    "[Failed to decrypt message]".to_string()
                });

            conversation.push_str(&format!("\n{}: {}\n", role, content));
        }

        Ok(conversation)
    }

    /// Helper: Make a structured AI call with JSON schema
    async fn call_ai_structured(
        &self,
        model: &str,
        prompt: &str,
    ) -> Result<Value, AppError> {
        use genai::chat::{
            ChatOptions as GenAiChatOptions, HarmBlockThreshold, HarmCategory, SafetySetting,
            ChatRole, MessageContent, ChatMessage as GenAiChatMessage
        };
        
        debug!("Making structured AI call to model: {}", model);
        
        // Create the user message
        let user_message = GenAiChatMessage {
            role: ChatRole::User,
            content: MessageContent::Text(prompt.to_string()),
            options: None,
        };

        // Build chat options for the AI call
        let mut genai_chat_options = GenAiChatOptions::default();
        
        // Set temperature for structured analysis (higher for planning, lower for triage)
        let temperature = if model.contains("pro") { 0.5 } else { 0.3 };
        genai_chat_options = genai_chat_options.with_temperature(temperature);
        
        // Set max tokens
        genai_chat_options = genai_chat_options.with_max_tokens(4096);
        
        // Add safety settings to allow analysis of any content
        let safety_settings = vec![
            SafetySetting::new(HarmCategory::Harassment, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::HateSpeech, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::SexuallyExplicit, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::DangerousContent, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::CivicIntegrity, HarmBlockThreshold::BlockNone),
        ];
        genai_chat_options = genai_chat_options.with_safety_settings(safety_settings);

        // Create system prompt for narrative analysis
        let system_prompt = "You are a narrative intelligence agent that analyzes roleplay conversations and manages story memory. You provide structured JSON responses following the exact schema requested.";

        // Create chat request
        let chat_req = genai::chat::ChatRequest::new(vec![user_message]).with_system(system_prompt);
        
        info!("Making AI call for narrative analysis with model: {}", model);
        
        // Call the AI client
        let response = self.ai_client
            .exec_chat(model, chat_req, Some(genai_chat_options))
            .await
            .map_err(|e| {
                error!("AI client call failed during narrative analysis: {}", e);
                AppError::LlmClientError(format!("Narrative analysis failed: {e}"))
            })?;

        info!("AI client call successful, processing response...");

        // Process the response to extract JSON value
        self.process_structured_response(response)
    }

    /// Process structured chat response to extract JSON value
    fn process_structured_response(
        &self,
        response: genai::chat::ChatResponse,
    ) -> Result<Value, AppError> {
        // Extract the first content as text
        let content = response.first_content_text_as_str().unwrap_or_default();
        info!("Processing structured response, content length: {} characters", content.len());
        
        // The response might be wrapped in markdown or be raw JSON
        let cleaned_content = if content.trim().starts_with("```json") {
            // Extract content between ```json and ```
            let start = content.find("```json").unwrap() + 7;
            let end = content.rfind("```").unwrap_or(content.len());
            content[start..end].trim()
        } else if content.trim().starts_with("```") {
            // Extract content between ``` and ```
            let start = content.find("```").unwrap() + 3;
            let end = content.rfind("```").unwrap_or(content.len());
            content[start..end].trim()
        } else {
            content.trim()
        };

        // Parse as JSON
        serde_json::from_str(cleaned_content)
            .map_err(|e| {
                error!("Failed to parse structured response as JSON: {}", e);
                debug!("Raw response content: {}", content);
                debug!("Cleaned content: {}", cleaned_content);
                AppError::InternalServerErrorGeneric(format!("Failed to parse structured response: {}", e))
            })
    }
}

/// Result of the complete narrative workflow execution
#[derive(Debug)]
pub struct NarrativeWorkflowResult {
    pub triage_result: TriageResult,
    pub actions_taken: Vec<PlannedAction>,
    pub execution_results: Vec<ToolResult>,
    pub cost_estimate: f64,
}