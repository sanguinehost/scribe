//! Agent runner for executing the multi-step agentic narrative workflow.

use serde_json::{json, Value};
use std::sync::Arc;
use tracing::{debug, error, info, warn};
use uuid::Uuid;
use secrecy::ExposeSecret;

use crate::{
    auth::session_dek::SessionDek,
    errors::AppError,
    llm::AiClient,
    models::{
        chats::ChatMessage,
        chronicle::CreateChronicleRequest,
    },
    services::ChronicleService,
};

use super::{
    registry::ToolRegistry,
    tools::{ToolParams, ToolResult},
};

/// Configuration for the narrative intelligence workflow
#[derive(Debug, Clone)]
pub struct NarrativeWorkflowConfig {
    /// Model to use for triage analysis (should be fast and cheap)
    pub triage_model: String,
    /// Model to use for reasoning and planning (can be more capable)
    pub planning_model: String,
    /// Maximum number of tools that can be executed in a single workflow
    pub max_tool_executions: usize,
    /// Whether to enable cost-saving optimizations
    pub enable_cost_optimizations: bool,
}

impl Default for NarrativeWorkflowConfig {
    fn default() -> Self {
        Self {
            triage_model: "gemini-2.5-flash-lite-preview-06-17".to_string(),
            planning_model: "gemini-2.5-pro".to_string(),
            max_tool_executions: 5,
            enable_cost_optimizations: true,
        }
    }
}

/// Result of the triage analysis step
#[derive(Debug, Clone)]
pub struct TriageResult {
    pub is_significant: bool,
    pub summary: String,
    pub event_type: String,
    pub confidence: f32,
}

/// A plan of action generated by the AI agent
#[derive(Debug, Clone)]
pub struct ActionPlan {
    pub reasoning: String,
    pub actions: Vec<PlannedAction>,
}

/// A single action in the plan
#[derive(Debug, Clone)]
pub struct PlannedAction {
    pub tool_name: String,
    pub parameters: ToolParams,
    pub reasoning: String,
}

/// Core agent runner that orchestrates the narrative intelligence workflow
pub struct NarrativeAgentRunner {
    ai_client: Arc<dyn AiClient>,
    tool_registry: Arc<ToolRegistry>,
    config: NarrativeWorkflowConfig,
    chronicle_service: Arc<ChronicleService>,
}

impl NarrativeAgentRunner {
    pub fn new(
        ai_client: Arc<dyn AiClient>,
        tool_registry: Arc<ToolRegistry>,
        config: NarrativeWorkflowConfig,
        chronicle_service: Arc<ChronicleService>,
    ) -> Self {
        Self {
            ai_client,
            tool_registry,
            config,
            chronicle_service,
        }
    }

    /// Execute the full narrative intelligence workflow for a set of chat messages
    pub async fn process_narrative_event(
        &self,
        user_id: Uuid,
        chat_session_id: Uuid,
        mut chronicle_id: Option<Uuid>,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
        persona_context: Option<super::UserPersonaContext>,
    ) -> Result<NarrativeWorkflowResult, AppError> {
        info!(
            "Starting narrative workflow for chat {} with {} messages",
            chat_session_id,
            messages.len()
        );

        // Step 1: Triage - Is this significant?
        let triage_result = self.perform_triage(user_id, chronicle_id, messages, session_dek, persona_context.as_ref()).await?;
        
        if !triage_result.is_significant {
            info!("Triage determined event is not significant, skipping workflow");
            return Ok(NarrativeWorkflowResult {
                triage_result,
                actions_taken: vec![],
                execution_results: vec![],
                cost_estimate: 0.0,
            });
        }

        info!("Event deemed significant: {}", triage_result.summary);

        // Track whether we just created a new chronicle
        let mut chronicle_was_just_created = false;

        // Auto-create and link chronicle if this is the first significant event for this chat
        if chronicle_id.is_none() {
            info!("Auto-creating chronicle for chat session {}", chat_session_id);
            
            // Generate a meaningful chronicle name based on the chat context
            let chronicle_name = self.generate_chronicle_name_from_messages(messages, session_dek).await?;
            let chronicle_description = format!(
                "Automatically created chronicle for chat session on {}",
                chrono::Utc::now().format("%Y-%m-%d %H:%M UTC")
            );
            
            let chronicle_request = CreateChronicleRequest {
                name: chronicle_name,
                description: Some(chronicle_description),
            };
            
            match self.chronicle_service.create_chronicle(user_id, chronicle_request).await {
                Ok(created_chronicle) => {
                    chronicle_id = Some(created_chronicle.id);
                    chronicle_was_just_created = true;
                    info!("Auto-created chronicle '{}': {}", created_chronicle.name, created_chronicle.id);
                    
                    // Link the chat session to the chronicle
                    if let Err(e) = self.chronicle_service.link_chat_session(user_id, chat_session_id, created_chronicle.id).await {
                        error!("Failed to link chronicle {} to chat session {}: {}", created_chronicle.id, chat_session_id, e);
                        // Continue anyway - the chronicle exists
                    } else {
                        info!("Successfully linked chronicle {} to chat session {}", created_chronicle.id, chat_session_id);
                    }
                },
                Err(e) => {
                    error!("Failed to auto-create chronicle for chat session {}: {}", chat_session_id, e);
                    // Continue without chronicle - events will be skipped but workflow continues
                }
            }
        }

        // Step 2: Knowledge Retrieval - What do we already know?
        let knowledge_context = self.retrieve_knowledge_context(&triage_result).await?;

        // Step 3: Planning - What should we do?
        let action_plan = self.generate_action_plan(
            &triage_result,
            &knowledge_context,
            chronicle_id,
            chronicle_was_just_created, // Pass this information to the planner
            persona_context.as_ref(),
        ).await?;

        info!("Generated action plan with {} actions", action_plan.actions.len());

        // Step 4: Execution - Execute the planned actions
        let execution_results = self.execute_action_plan(&action_plan, user_id, chronicle_id, session_dek, persona_context.as_ref()).await?;

        Ok(NarrativeWorkflowResult {
            triage_result,
            actions_taken: action_plan.actions,
            execution_results,
            cost_estimate: 0.0, // TODO: Implement cost tracking
        })
    }

    /// Step 1: Analyze if the conversation contains significant narrative events
    async fn perform_triage(
        &self,
        user_id: Uuid,
        chronicle_id: Option<Uuid>,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
        persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<TriageResult, AppError> {
        debug!("Performing narrative triage on {} messages", messages.len());

        // Build conversation text
        let conversation_text = self.build_conversation_text(messages, session_dek).await?;

        // Get recent chronicle context for deduplication and temporal awareness
        let recent_chronicles_context = if let Some(chron_id) = chronicle_id {
            self.get_recent_chronicle_context(user_id, chron_id).await.unwrap_or_default()
        } else {
            String::new()
        };
        
        // Build persona context section
        let persona_section = if let Some(persona) = persona_context {
            format!("\n{}\n", persona.to_prompt_context())
        } else {
            String::new()
        };

        let triage_prompt = format!(
            r#"Analyze this roleplay conversation and determine if it contains narratively significant events.
{}
CONVERSATION:
{}

RECENT CHRONICLE EVENTS (last 10 events for deduplication):
{}

You are analyzing according to the Ars Fabula narrative ontology. Respond with a JSON object:
{{
    "is_significant": boolean, // true if this contains events worth recording
    "summary": "string", // brief summary of what happened (if significant)
    "event_category": "string", // Primary narrative pillar: WORLD, CHARACTER, PLOT, RELATIONSHIP
    "event_type": "string", // Abstract category: DISCOVERY, ALTERATION, LORE_EXPANSION, STATE_CHANGE, DEVELOPMENT, PROGRESSION, REVELATION, TURNING_POINT, FORMATION, MODIFICATION, INTERACTION
    "narrative_action": "string", // Core verb: DISCOVERED, REVEALED, MET, ATTACKED, ACQUIRED, DIED, BETRAYED, TOLD, DECIDED, etc.
    "primary_agent": "string", // Name of entity initiating the action (if any)
    "primary_patient": "string", // Name of entity being acted upon (if any)
    "confidence": float // 0.0-1.0 confidence in this assessment
}}

SIGNIFICANCE CRITERIA (Ars Fabula Event Ontology):

WORLD Events (Changes to the physical/conceptual reality):
- DISCOVERY + DISCOVERED/FOUND: New locations, items, secrets, knowledge
- ALTERATION + TRANSFORMED/CHANGED: Environmental changes, world state shifts  
- LORE_EXPANSION + REVEALED/TOLD: Learning history, understanding mechanics

CHARACTER Events (Individual entity changes):
- STATE_CHANGE + DIED/TRANSFORMED: Death, injury, fundamental change
- DEVELOPMENT + ACQUIRED/EVOLVED: Skill gains, power increases, growth
- PROGRESSION + DECIDED/COMMITTED: Character arc advancement, goal changes

PLOT Events (Narrative structure progression):
- REVELATION + REVEALED/DISCOVERED: Secrets uncovered, mysteries solved
- TURNING_POINT + DECIDED/CHOSE: Critical decisions, plot branches
- PROGRESSION + ADVANCED/COMPLETED: Quest advancement, story milestone

RELATIONSHIP Events (Social dynamics):
- FORMATION + MET/BEFRIENDED: New relationships, alliances formed
- MODIFICATION + BETRAYED/CHANGED: Relationship shifts, trust changes
- INTERACTION + TOLD/ASKED: Significant dialogue, negotiations

Examples:
- Character death: WORLD.STATE_CHANGE + DIED, agent=killer, patient=victim
- Meeting someone: RELATIONSHIP.FORMATION + MET, agent=character1, patient=character2
- Finding treasure: WORLD.DISCOVERY + DISCOVERED, agent=finder, object=treasure
- Learning secret: PLOT.REVELATION + REVEALED, agent=revealer, patient=learner

Consider NOT significant:
- Routine conversation without impact
- Movement without discovery or consequence  
- Minor interactions without relationship change
- Events already covered in recent chronicle entries (check RECENT CHRONICLE EVENTS above)
- Scene details that don't advance the plot or change world state
- Sexual content without narrative significance or character development
- Repetitive interactions already documented

TEMPORAL SCOPE PRIORITIZATION:
- Prioritize MAJOR PLOT EVENTS over scene details
- Focus on actions with lasting consequences over momentary interactions  
- Divine interventions, world-changing events, and character arcs take precedence
- Distinguish between story beats (significant) vs flavor text (insignificant)
- Events spanning longer time periods (months, years) are typically more significant than minute-by-minute actions
- Global consequences and governmental responses indicate high significance

DEDUPLICATION RULES:
- If a similar event is already in RECENT CHRONICLE EVENTS, mark as NOT significant
- Look for redundant themes, locations, or character interactions
- Avoid chronicling the same type of event multiple times in a short period

IMPORTANT: When identifying characters in the conversation, use the persona context above to properly identify who is who. Do not refer to characters generically as "the user" or "the character" when you have specific persona information available."#,
            persona_section,
            conversation_text,
            recent_chronicles_context
        );

        // Call AI for triage
        let response = self.call_ai_structured(&self.config.triage_model, &triage_prompt).await?;

        // Parse response
        let is_significant = response.get("is_significant")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        let summary = response.get("summary")
            .and_then(|v| v.as_str())
            .unwrap_or("No summary provided")
            .to_string();

        let event_type = response.get("event_type")
            .and_then(|v| v.as_str())
            .unwrap_or("UNKNOWN")
            .to_string();

        let confidence = response.get("confidence")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5) as f32;

        Ok(TriageResult {
            is_significant,
            summary,
            event_type,
            confidence,
        })
    }

    /// Step 2: Retrieve relevant knowledge from existing chronicles/lorebooks
    async fn retrieve_knowledge_context(
        &self,
        triage_result: &TriageResult,
    ) -> Result<Value, AppError> {
        debug!("Retrieving knowledge context for: {}", triage_result.summary);

        // Use the search tool to find relevant context
        let search_tool = self.tool_registry.get_tool("search_knowledge_base")
            .map_err(|e| AppError::InternalServerErrorGeneric(format!("Search tool not available: {}", e)))?;

        let search_params = json!({
            "query": triage_result.summary,
            "search_type": "all",
            "limit": 10
        });

        match search_tool.execute(&search_params).await {
            Ok(results) => Ok(results),
            Err(e) => {
                warn!("Knowledge search failed: {}", e);
                // Return empty context on failure
                Ok(json!({"results": []}))
            }
        }
    }

    /// Step 3: Generate an action plan based on the event and existing knowledge
    async fn generate_action_plan(
        &self,
        triage_result: &TriageResult,
        knowledge_context: &Value,
        chronicle_id: Option<Uuid>,
        chronicle_was_just_created: bool,
        persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<ActionPlan, AppError> {
        debug!("Generating action plan for event: {}", triage_result.event_type);

        // Dynamically build available tools list based on what's actually registered
        let available_tools = self.tool_registry.list_tools();
        let mut tools_description = String::new();
        
        for tool_name in &available_tools {
            match tool_name.as_str() {
                "create_chronicle_event" => {
                    tools_description.push_str("- create_chronicle_event: Record temporal, player-centric events that happened at specific times\n");
                }
                "create_lorebook_entry" => {
                    tools_description.push_str("- create_lorebook_entry: Create NEW lorebook entries for persistent world concepts (characters, locations, items, lore)\n");
                }
                "update_lorebook_entry" => {
                    tools_description.push_str("- update_lorebook_entry: Update existing lorebook entries when world state changes\n");
                }
                "search_knowledge_base" => {
                    tools_description.push_str("- search_knowledge_base: Find existing information (already done above)\n");
                }
                _ => {
                    // Skip other tools that aren't relevant for planning
                }
            }
        }

        // Build persona context section
        let persona_section = if let Some(persona) = persona_context {
            format!("\n{}\n", persona.to_prompt_context())
        } else {
            String::new()
        };

        let planning_prompt = format!(
            r#"You are an Ars Fabula narrative intelligence agent. Based on the event analysis, create a plan to update the narrative knowledge base.
{}
EVENT ANALYSIS:
- Type: {}
- Summary: {}
- Confidence: {}

EXISTING KNOWLEDGE:
{}

AVAILABLE TOOLS:
{}

CHRONICLE ID: {}
CHRONICLE JUST CREATED: {}

{}

Create a JSON plan following Ars Fabula principles:
{{
    "reasoning": "string explaining your logic and narrative impact",
    "actions": [
        {{
            "tool_name": "string",
            "parameters": {{}},
            "reasoning": "string explaining why this action advances the Fabula"
        }}
    ]
}}

ARS FABULA NARRATIVE ONTOLOGY RULES:

1.  **TEMPORAL EVENTS (for create_chronicle_event):**
    *   **Structure:** Events must be atomic and capture a single, significant moment.
    *   **`event_type`:** Use dot-notation: `CATEGORY.TYPE.SUBTYPE` (e.g., `CHARACTER.STATE_CHANGE.DEATH`).
    *   **`actors`:** A JSON array detailing all participants and their roles (`Agent`, `Patient`, `Beneficiary`, `Instrument`, `Witness`).
    *   **`action`:** The core verb of the event (e.g., `Betrayed`, `Discovered`, `Killed`).
    *   **`causality`:** A JSON object with `causedBy` (an array of event IDs that led to this one) and `causes` (an array of event IDs this one leads to). Use this to link events into a causal chain. If an event in EXISTING KNOWLEDGE is a direct cause, reference its ID.
    *   **`valence`:** A JSON array quantifying emotional/relational impact. Each object needs a `target` (entity ID), `type` (`Trust`, `Fear`, `Health`, `Power`), and `change` (float from -1.0 to 1.0).
    *   **`context_data`:** A JSON object for situational context like `location_id`, `time_of_day`, etc.

2.  **PERSISTENT CONCEPTS (for create_lorebook_entry):**
    *   Create entries for **new, persistent entities** (characters, locations, items, organizations) that are likely to be mentioned again.
    *   Focus on timeless, factual information.

3.  **KNOWLEDGE INTEGRATION:**
    *   **CRITICAL:** Review EXISTING KNOWLEDGE to avoid creating duplicate events or lorebook entries.
    *   If a similar event exists, consider if this is new information that should **update** an existing lorebook entry instead of creating a new event.
    *   Use the `causality` field to explicitly link new events to existing ones.

4.  **TOOL PARAMETERS for `create_chronicle_event`:**
    *   `event_type` (string): e.g., "PLOT.REVELATION.SECRET"
    *   `action` (string): e.g., "Revealed"
    *   `actors` (JSON array): `[{{\"id\": \"...\", \"role\": \"Agent\"}}, ...]`
    *   `summary` (string): A brief, one-sentence summary.
    *   `causality` (JSON object): `{{"causedBy": ["..."], "causes": []}}`
    *   `valence` (JSON array): `[{{"target": "...", "type": "Trust", "change": -0.5}}]`
    *   `context_data` (JSON object): `{{"location_id": "..."}}`

5.  ONLY use tools listed in AVAILABLE TOOLS above.
6.  Prioritize narrative significance and causal coherence.
7.  Ensure events contribute meaningfully to the emergent Fabula.

IMPORTANT: When creating chronicle events, use the persona context above to properly identify who is who. Do not refer to characters generically as "the user" or "the character" when you have specific persona information available. Use actual character names in the subject, object, and involved_entities fields."#,
            persona_section,
            triage_result.event_type,
            triage_result.summary,
            triage_result.confidence,
            serde_json::to_string_pretty(knowledge_context).unwrap_or_default(),
            tools_description,
            chronicle_id.map(|id| id.to_string()).unwrap_or_else(|| "None".to_string()),
            chronicle_was_just_created,
            if chronicle_was_just_created {
                "IMPORTANT: A new chronicle was JUST created for this significant event. You MUST create at least one chronicle_event to record this founding moment that triggered the chronicle's creation. This is the FIRST event in a new chronicle!"
            } else {
                ""
            }
        );

        let response = self.call_ai_structured(&self.config.planning_model, &planning_prompt).await?;

        let reasoning = response.get("reasoning")
            .and_then(|v| v.as_str())
            .unwrap_or("No reasoning provided")
            .to_string();

        let actions = response.get("actions")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|action| {
                        let tool_name = action.get("tool_name")?.as_str()?.to_string();
                        let parameters = action.get("parameters")?.clone();
                        let action_reasoning = action.get("reasoning")
                            .and_then(|v| v.as_str())
                            .unwrap_or("No reasoning")
                            .to_string();

                        Some(PlannedAction {
                            tool_name,
                            parameters,
                            reasoning: action_reasoning,
                        })
                    })
                    .collect()
            })
            .unwrap_or_default();

        Ok(ActionPlan { reasoning, actions })
    }

    /// Step 4: Execute the planned actions
    async fn execute_action_plan(
        &self,
        plan: &ActionPlan,
        user_id: Uuid,
        chronicle_id: Option<Uuid>,
        session_dek: &SessionDek,
        _persona_context: Option<&super::UserPersonaContext>,
    ) -> Result<Vec<ToolResult>, AppError> {
        info!("Executing action plan with {} actions", plan.actions.len());

        // Chronicle should already be created at workflow level if needed

        let mut results = Vec::new();

        for (index, action) in plan.actions.iter().enumerate() {
            if index >= self.config.max_tool_executions {
                warn!("Reached maximum tool execution limit ({})", self.config.max_tool_executions);
                break;
            }

            debug!("Executing action {}: {} - {}", index + 1, action.tool_name, action.reasoning);

            match self.tool_registry.get_tool(&action.tool_name) {
                Ok(tool) => {
                    // Inject required context parameters into tool calls
                    let mut enriched_parameters = action.parameters.clone();
                    
                    // Add user_id, chronicle_id, and session_dek for tools that need them
                    if action.tool_name == "create_chronicle_event" || action.tool_name == "create_lorebook_entry" {
                        if let serde_json::Value::Object(ref mut obj) = enriched_parameters {
                            // Add user_id if not present
                            if !obj.contains_key("user_id") {
                                obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            }
                            
                            // Add chronicle_id if not present and available (for chronicle events)
                            if action.tool_name == "create_chronicle_event" && !obj.contains_key("chronicle_id") {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            // Add session_dek for both lorebook and chronicle event creation (encryption required!)
                            if (action.tool_name == "create_lorebook_entry" || action.tool_name == "create_chronicle_event") && !obj.contains_key("session_dek") {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                        } else {
                            // If parameters is not an object, create one with required fields
                            let mut obj = serde_json::Map::new();
                            obj.insert("user_id".to_string(), serde_json::Value::String(user_id.to_string()));
                            
                            if action.tool_name == "create_chronicle_event" {
                                if let Some(chron_id) = chronicle_id {
                                    obj.insert("chronicle_id".to_string(), serde_json::Value::String(chron_id.to_string()));
                                }
                            }
                            
                            if action.tool_name == "create_lorebook_entry" || action.tool_name == "create_chronicle_event" {
                                let session_dek_hex = hex::encode(session_dek.0.expose_secret());
                                obj.insert("session_dek".to_string(), serde_json::Value::String(session_dek_hex));
                            }
                            
                            // Merge with existing parameters if they were in a different format
                            if let Ok(existing_obj) = serde_json::from_value::<serde_json::Map<String, serde_json::Value>>(action.parameters.clone()) {
                                obj.extend(existing_obj);
                            }
                            enriched_parameters = serde_json::Value::Object(obj);
                        }
                    }
                    
                    debug!("Executing {} tool with enriched params: {}", action.tool_name, serde_json::to_string(&enriched_parameters).unwrap_or_default());
                    
                    match tool.execute(&enriched_parameters).await {
                        Ok(result) => {
                            info!("Successfully executed tool: {}", action.tool_name);
                            results.push(result);
                        }
                        Err(e) => {
                            error!("Tool execution failed for {}: {}", action.tool_name, e);
                            // Continue with other actions even if one fails
                            results.push(json!({
                                "success": false,
                                "error": e.to_string(),
                                "tool": action.tool_name
                            }));
                        }
                    }
                }
                Err(e) => {
                    error!("Tool not found: {} - {}", action.tool_name, e);
                    results.push(json!({
                        "success": false,
                        "error": format!("Tool not found: {}", action.tool_name)
                    }));
                }
            }
        }

        Ok(results)
    }

    /// Helper: Build conversation text from messages
    async fn build_conversation_text(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<String, AppError> {
        let mut conversation = String::new();

        for message in messages.iter().take(10) { // Limit to last 10 messages for cost control
            let role = match message.message_type {
                crate::models::chats::MessageRole::User => "User",
                crate::models::chats::MessageRole::Assistant => "Assistant",
                crate::models::chats::MessageRole::System => "System",
            };

            let content = message.decrypt_content_field(&session_dek.0)
                .unwrap_or_else(|e| {
                    warn!("Failed to decrypt message {}: {}", message.id, e);
                    "[Failed to decrypt message]".to_string()
                });

            conversation.push_str(&format!("\n{}: {}\n", role, content));
        }

        Ok(conversation)
    }

    /// Generate a meaningful chronicle name based on chat messages  
    async fn generate_chronicle_name_from_messages(
        &self,
        messages: &[ChatMessage],
        session_dek: &SessionDek,
    ) -> Result<String, AppError> {
        // Build a sample of the conversation for analysis
        let conversation_sample = self.build_conversation_text(messages, session_dek).await?;
        
        // Use AI to generate a meaningful chronicle name based on the conversation
        let name_prompt = format!(
            r#"Based on this roleplay conversation, generate a short, descriptive chronicle name (max 60 characters).
Focus on the main characters, setting, or central theme. Make it engaging and specific.

Examples of good names:
- "Thorin's Quest for Erebor"
- "The Dragon's Last Stand" 
- "Adventures in the Feywild"
- "Detective Sarah's Case Files"

Conversation:
{}

Respond with ONLY the chronicle name, no quotes or explanation:"#,
            conversation_sample.chars().take(2000).collect::<String>()
        );

        match self.call_ai_for_simple_task(&name_prompt).await {
            Ok(generated_name) => {
                let clean_name = generated_name.trim().trim_matches('"').trim_matches('\'');
                if clean_name.len() > 3 && clean_name.len() <= 60 {
                    Ok(clean_name.to_string())
                } else {
                    // Fallback if AI generated something weird
                    Ok(format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M")))
                }
            },
            Err(_) => {
                // Fallback if AI call fails
                Ok(format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M")))
            }
        }
    }

    /// Generate a meaningful chronicle name based on the planned actions
    fn generate_chronicle_name(&self, actions: &[PlannedAction]) -> String {
        // Look for chronicle events and extract meaningful subjects/themes
        let mut subjects = Vec::new();
        let mut event_types = Vec::new();
        
        for action in actions {
            if action.tool_name == "create_chronicle_event" {
                // Try to extract subject and event type from parameters
                if let Some(subject) = action.parameters.get("subject").and_then(|v| v.as_str()) {
                    if !subjects.contains(&subject.to_string()) {
                        subjects.push(subject.to_string());
                    }
                }
                
                if let Some(event_subtype) = action.parameters.get("event_subtype").and_then(|v| v.as_str()) {
                    if !event_types.contains(&event_subtype.to_string()) {
                        event_types.push(event_subtype.to_string());
                    }
                }
            }
        }
        
        // Generate name based on content
        if !subjects.is_empty() {
            let primary_subject = &subjects[0];
            
            if !event_types.is_empty() {
                let primary_event = &event_types[0];
                // Convert event type to readable format
                let readable_event = primary_event
                    .replace("_", " ")
                    .to_lowercase();
                
                if subjects.len() == 1 {
                    format!("{}: {}", primary_subject, readable_event)
                } else {
                    format!("{} & {} others: {}", primary_subject, subjects.len() - 1, readable_event)
                }
            } else {
                if subjects.len() == 1 {
                    format!("{}'s Chronicle", primary_subject)
                } else {
                    format!("{} & {} others", primary_subject, subjects.len() - 1)
                }
            }
        } else if !event_types.is_empty() {
            let primary_event = &event_types[0];
            let readable_event = primary_event
                .replace("_", " ")
                .to_lowercase();
            
            if event_types.len() == 1 {
                format!("Chronicle of {}", readable_event)
            } else {
                format!("Chronicle of {} & more", readable_event)
            }
        } else {
            // Fallback with timestamp to ensure uniqueness
            format!("Chronicle {}", chrono::Utc::now().format("%Y-%m-%d %H:%M"))
        }
    }
    
    /// Helper method to call AI for simple text generation tasks
    async fn call_ai_for_simple_task(&self, prompt: &str) -> Result<String, AppError> {
        use genai::chat::{
            ChatOptions as GenAiChatOptions, ChatRole, MessageContent, ChatMessage as GenAiChatMessage
        };
        
        let user_message = GenAiChatMessage {
            role: ChatRole::User,
            content: MessageContent::Text(prompt.to_string()),
            options: None,
        };

        let mut genai_chat_options = GenAiChatOptions::default();
        genai_chat_options = genai_chat_options.with_temperature(0.7); // Creative but focused
        genai_chat_options = genai_chat_options.with_max_tokens(100); // Short response
        
        let system_prompt = "You are a creative assistant that generates engaging, concise chronicle names for roleplay stories.";
        let chat_req = genai::chat::ChatRequest::new(vec![user_message]).with_system(system_prompt);
        
        let response = self.ai_client
            .exec_chat("gemini-2.5-flash-lite-preview-06-17", chat_req, Some(genai_chat_options))
            .await
            .map_err(|e| AppError::LlmClientError(format!("AI call failed: {}", e)))?;

        Ok(response.first_content_text_as_str().unwrap_or_default().to_string())
    }

    /// Helper: Get comprehensive chronicle context for deduplication and temporal awareness
    /// 
    /// Implements Ars Fabula's Temporal Event Graph architecture (Part V, Section 5.1):
    /// This performs graph-based traversal of the chronicle's causal and temporal structure
    /// to provide comprehensive context spanning years of narrative history at scale.
    /// 
    /// Strategy:
    /// 1. Recent temporal window (chronological recency)
    /// 2. Causal chain traversal (following causality links)
    /// 3. Semantic similarity for thematic relevance
    /// 4. Temporal sampling across narrative epochs
    async fn get_recent_chronicle_context(
        &self,
        _user_id: Uuid,
        chronicle_id: Uuid,
    ) -> Result<String, AppError> {
        let search_tool = self.tool_registry.get_tool("search_knowledge_base")
            .map_err(|e| AppError::InternalServerErrorGeneric(format!("Search tool not available: {}", e)))?;

        let mut context_sections = Vec::new();
        
        // === ARS FABULA TEMPORAL EVENT GRAPH IMPLEMENTATION ===
        // Following Part V, Section 5.1: "complete, chronologically-ordered log of all Narrative Events"
        // This implements proper graph-based retrieval for massive scale (millions of events)
        
        // LAYER 1: Recent Temporal Window (Chronological Priority)
        // Get the most recent 50 events by timestamp for immediate deduplication
        let recent_params = json!({
            "query": "chronicle events",
            "search_type": "chronicles",
            "limit": 50,
            "chronicle_filter": chronicle_id.to_string(),
            "sort": "temporal_desc", // Most recent first by timestamp
            "temporal_window": "recent" // Hint for chronological priority over semantic similarity
        });

        if let Ok(recent_results) = search_tool.execute(&recent_params).await {
            if let Some(events) = recent_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut recent_context = String::from("RECENT TEMPORAL WINDOW (last 30 events):\n");
                    for (i, event) in events.iter().take(30).enumerate() {
                        if let (Some(summary), Some(event_type), Some(timestamp)) = (
                            event.get("content").and_then(|c| c.as_str()),
                            event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str()),
                            event.get("metadata").and_then(|m| m.get("timestamp")).and_then(|t| t.as_str())
                        ) {
                            recent_context.push_str(&format!(
                                "{}. [{}] {}: {}\n", 
                                i + 1,
                                timestamp.split('T').next().unwrap_or("unknown"),
                                event_type,
                                summary.chars().take(100).collect::<String>()
                            ));
                        }
                    }
                    context_sections.push(recent_context);
                }
            }
        }

        // LAYER 2: Causal Chain Traversal (Following causality links)
        // This implements the DAG traversal mentioned in Part I for causal reasoning
        let causal_params = json!({
            "query": "causal relationships",
            "search_type": "chronicles",
            "limit": 30,
            "chronicle_filter": chronicle_id.to_string(),
            "graph_traversal": "causal_chains", // Follow causedBy/causes links
            "causality_depth": 3 // Traverse 3 levels of causal connections
        });

        if let Ok(causal_results) = search_tool.execute(&causal_params).await {
            if let Some(events) = causal_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut causal_context = String::from("CAUSAL CHAIN CONTEXT (connected events):\n");
                    for (i, event) in events.iter().take(20).enumerate() {
                        if let (Some(summary), Some(event_type)) = (
                            event.get("content").and_then(|c| c.as_str()),
                            event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str())
                        ) {
                            causal_context.push_str(&format!(
                                "{}. {}: {}\n", 
                                i + 1,
                                event_type,
                                summary.chars().take(90).collect::<String>()
                            ));
                        }
                    }
                    context_sections.push(causal_context);
                }
            }
        }

        // LAYER 3: Semantic Similarity for Thematic Relevance
        // Targeted semantic search for thematically related events across the timeline
        let semantic_params = json!({
            "query": "narrative themes relationships characters world changes", // Broad thematic query
            "search_type": "chronicles",
            "limit": 40,
            "chronicle_filter": chronicle_id.to_string(),
            "score_threshold": 0.75, // High relevance threshold
            "temporal_distribution": true // Sample across different time periods
        });

        if let Ok(semantic_results) = search_tool.execute(&semantic_params).await {
            if let Some(events) = semantic_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut semantic_context = String::from("THEMATIC CONTEXT (related across time):\n");
                    let mut seen_ids = std::collections::HashSet::new();
                    let mut count = 0;

                    for event in events.iter().take(25) {
                        if let Some(event_id) = event.get("id") {
                            if seen_ids.insert(event_id.clone()) && count < 15 {
                                if let (Some(summary), Some(event_type), Some(score)) = (
                                    event.get("content").and_then(|c| c.as_str()),
                                    event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str()),
                                    event.get("score").and_then(|s| s.as_f64())
                                ) {
                                    count += 1;
                                    semantic_context.push_str(&format!(
                                        "{}. {} (rel: {:.2}): {}\n", 
                                        count,
                                        event_type,
                                        score,
                                        summary.chars().take(85).collect::<String>()
                                    ));
                                }
                            }
                        }
                    }
                    if count > 0 {
                        context_sections.push(semantic_context);
                    }
                }
            }
        }

        // LAYER 4: Temporal Epochal Sampling (Historical Depth)
        // Sample significant events across different narrative epochs for 5+ year context
        let epochal_params = json!({
            "query": "major historical significant events",
            "search_type": "chronicles", 
            "limit": 60,
            "chronicle_filter": chronicle_id.to_string(),
            "temporal_sampling": "epochal", // Sample across different time periods
            "significance_threshold": 0.85, // Only very significant events
            "max_age": "unlimited" // Include ancient events
        });

        if let Ok(epochal_results) = search_tool.execute(&epochal_params).await {
            if let Some(events) = epochal_results.get("results").and_then(|r| r.as_array()) {
                if !events.is_empty() {
                    let mut epochal_context = String::from("HISTORICAL EPOCHS (major events across years):\n");
                    for (i, event) in events.iter().take(12).enumerate() {
                        if let (Some(summary), Some(event_type), Some(timestamp)) = (
                            event.get("content").and_then(|c| c.as_str()),
                            event.get("metadata").and_then(|m| m.get("event_type")).and_then(|t| t.as_str()),
                            event.get("metadata").and_then(|m| m.get("timestamp")).and_then(|t| t.as_str())
                        ) {
                            epochal_context.push_str(&format!(
                                "{}. [{}] {}: {}\n", 
                                i + 1,
                                timestamp.split('T').next().unwrap_or("ancient"),
                                event_type,
                                summary.chars().take(70).collect::<String>()
                            ));
                        }
                    }
                    context_sections.push(epochal_context);
                }
            }
        }

        // Assemble comprehensive context according to Ars Fabula principles
        if context_sections.is_empty() {
            Ok("No existing chronicle events found. This appears to be the beginning of the narrative.".to_string())
        } else {
            Ok(format!(
                "ARS FABULA TEMPORAL EVENT GRAPH CONTEXT:\n\n{}\n\n== DEDUPLICATION INSTRUCTIONS ==\nCarefully review ALL sections above. Do NOT create chronicle events that are:\n- Already covered in recent temporal window\n- Redundant with causally connected events\n- Thematically repetitive with existing context\n- Minor scene details when major historical events exist\n\nPrioritize NEW narrative developments that advance the Fabula without redundancy.",
                context_sections.join("\n")
            ))
        }
    }

    /// Helper: Make a structured AI call with JSON schema
    async fn call_ai_structured(
        &self,
        model: &str,
        prompt: &str,
    ) -> Result<Value, AppError> {
        use genai::chat::{
            ChatOptions as GenAiChatOptions, HarmBlockThreshold, HarmCategory, SafetySetting,
            ChatRole, MessageContent, ChatMessage as GenAiChatMessage
        };
        
        debug!("Making structured AI call to model: {}", model);
        
        // Create the user message
        let user_message = GenAiChatMessage {
            role: ChatRole::User,
            content: MessageContent::Text(prompt.to_string()),
            options: None,
        };

        // Build chat options for the AI call
        let mut genai_chat_options = GenAiChatOptions::default();
        
        // Set temperature for structured analysis (higher for planning, lower for triage)
        let temperature = if model.contains("pro") { 0.5 } else { 0.3 };
        genai_chat_options = genai_chat_options.with_temperature(temperature);
        
        // Set max tokens
        genai_chat_options = genai_chat_options.with_max_tokens(8192);
        
        // Add safety settings to allow analysis of any content
        let safety_settings = vec![
            SafetySetting::new(HarmCategory::Harassment, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::HateSpeech, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::SexuallyExplicit, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::DangerousContent, HarmBlockThreshold::BlockNone),
            SafetySetting::new(HarmCategory::CivicIntegrity, HarmBlockThreshold::BlockNone),
        ];
        genai_chat_options = genai_chat_options.with_safety_settings(safety_settings);

        // Create system prompt for narrative analysis
        let system_prompt = "You are a narrative intelligence agent that analyzes roleplay conversations and manages story memory. You provide structured JSON responses following the exact schema requested.";

        // Create chat request
        let chat_req = genai::chat::ChatRequest::new(vec![user_message]).with_system(system_prompt);
        
        info!("Making AI call for narrative analysis with model: {}", model);
        
        // Call the AI client
        let response = self.ai_client
            .exec_chat(model, chat_req, Some(genai_chat_options))
            .await
            .map_err(|e| {
                error!("AI client call failed during narrative analysis: {}", e);
                AppError::LlmClientError(format!("Narrative analysis failed: {e}"))
            })?;

        info!("AI client call successful, processing response...");

        // Process the response to extract JSON value
        self.process_structured_response(response)
    }

    /// Process structured chat response to extract JSON value
    fn process_structured_response(
        &self,
        response: genai::chat::ChatResponse,
    ) -> Result<Value, AppError> {
        // Extract the first content as text
        let content = response.first_content_text_as_str().unwrap_or_default();
        info!("Processing structured response, content length: {} characters", content.len());
        
        // The response might be wrapped in markdown or be raw JSON
        let cleaned_content = if content.trim().starts_with("```json") {
            // Extract content between ```json and closing ```
            let start_marker = "```json";
            if let Some(start_pos) = content.find(start_marker) {
                let start = start_pos + start_marker.len();
                // Find closing ``` after the opening marker
                if let Some(end_pos) = content[start..].find("```") {
                    let end = start + end_pos;
                    if end > start {
                        content[start..end].trim()
                    } else {
                        content.trim()
                    }
                } else {
                    // No closing ```, take everything after ```json
                    content[start..].trim()
                }
            } else {
                content.trim()
            }
        } else if content.trim().starts_with("```") {
            // Extract content between ``` and closing ```
            let start_marker = "```";
            if let Some(start_pos) = content.find(start_marker) {
                let start = start_pos + start_marker.len();
                // Find closing ``` after the opening marker
                if let Some(end_pos) = content[start..].find("```") {
                    let end = start + end_pos;
                    if end > start {
                        content[start..end].trim()
                    } else {
                        content.trim()
                    }
                } else {
                    // No closing ```, take everything after ```
                    content[start..].trim()
                }
            } else {
                content.trim()
            }
        } else {
            content.trim()
        };

        // Try to parse as JSON first
        match serde_json::from_str(cleaned_content) {
            Ok(value) => Ok(value),
            Err(e) => {
                error!("Failed to parse structured response as JSON: {}", e);
                error!("Raw response content (first 500 chars): {}", &content[..content.len().min(500)]);
                error!("Cleaned content (first 500 chars): {}", &cleaned_content[..cleaned_content.len().min(500)]);
                
                // Log the problematic line and column
                let line = e.line();
                let column = e.column();
                let lines: Vec<&str> = cleaned_content.lines().collect();
                if let Some(error_line) = lines.get(line.saturating_sub(1)) {
                    error!("Error at line {}, column {}: '{}'", line, column, error_line);
                    error!("Character at error position: '{}'", 
                        error_line.chars().nth(column.saturating_sub(1)).unwrap_or(' '));
                }

                // Attempt to fix common JSON issues and retry parsing
                info!("Attempting JSON repair and retry...");
                let repaired_json = self.repair_json_string(cleaned_content);
                
                match serde_json::from_str(&repaired_json) {
                    Ok(value) => {
                        warn!("Successfully parsed JSON after repair");
                        return Ok(value);
                    }
                    Err(repair_error) => {
                        error!("JSON repair attempt failed: {}", repair_error);
                        error!("Repaired content (first 500 chars): {}", &repaired_json[..repaired_json.len().min(500)]);
                    }
                }

                // Try to find JSON object boundaries and recover as last resort
                if let Some(start_brace) = cleaned_content.find('{') {
                    if let Some(end_brace) = cleaned_content.rfind('}') {
                        if end_brace > start_brace {
                            let potential_json = &cleaned_content[start_brace..=end_brace];
                            let repaired_potential = self.repair_json_string(potential_json);
                            match serde_json::from_str(&repaired_potential) {
                                Ok(value) => {
                                    warn!("Successfully recovered JSON after boundary extraction and repair");
                                    return Ok(value);
                                }
                                Err(_) => {
                                    error!("Final JSON recovery attempt also failed");
                                }
                            }
                        }
                    }
                }
                
                Err(AppError::InternalServerErrorGeneric(format!("Failed to parse structured response: {}", e)))
            }
        }
    }

    /// Repair common JSON formatting issues, particularly unescaped quotes in string values
    fn repair_json_string(&self, json_str: &str) -> String {
        // Common repair strategies for AI-generated JSON
        let mut repaired = json_str.to_string();
        
        // Strategy 1: Fix unescaped quotes within string values
        // This is the most common issue where AI generates: "reasoning": "He said "hello" to me"
        // We need to escape quotes that are inside string values but not the ones that are JSON delimiters
        repaired = self.fix_unescaped_quotes_in_strings(&repaired);
        
        // Strategy 2: Remove any trailing commas before closing braces/brackets
        repaired = regex::Regex::new(r",(\s*[}\]])").unwrap()
            .replace_all(&repaired, "$1")
            .to_string();
        
        // Strategy 3: Fix common newline issues within strings
        repaired = repaired.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
        
        // Strategy 4: Ensure proper boolean/null values (case sensitive)
        repaired = regex::Regex::new(r":\s*(True|TRUE)\b").unwrap()
            .replace_all(&repaired, ": true")
            .to_string();
        repaired = regex::Regex::new(r":\s*(False|FALSE)\b").unwrap()
            .replace_all(&repaired, ": false")
            .to_string();
        repaired = regex::Regex::new(r":\s*(None|NULL)\b").unwrap()
            .replace_all(&repaired, ": null")
            .to_string();
        
        repaired
    }
    
    /// Fix unescaped quotes within JSON string values
    fn fix_unescaped_quotes_in_strings(&self, json_str: &str) -> String {
        let mut result = String::with_capacity(json_str.len() * 2);
        let mut chars = json_str.chars().peekable();
        let mut in_string = false;
        let mut escape_next = false;
        
        while let Some(ch) = chars.next() {
            match ch {
                '"' if !escape_next => {
                    // This is either starting/ending a string or an unescaped quote inside a string
                    if in_string {
                        // Check if this is really the end of the string by looking ahead
                        // Skip whitespace and see if we find a colon, comma, or closing brace/bracket
                        let mut lookahead = chars.clone();
                        let mut found_whitespace_only = true;
                        
                        while let Some(&next_ch) = lookahead.peek() {
                            if next_ch.is_whitespace() {
                                lookahead.next();
                            } else {
                                found_whitespace_only = false;
                                break;
                            }
                        }
                        
                        if let Some(&next_non_ws) = lookahead.peek() {
                            if matches!(next_non_ws, ':' | ',' | '}' | ']') || found_whitespace_only {
                                // This is likely the end of the string
                                in_string = false;
                                result.push('"');
                            } else {
                                // This is likely an unescaped quote inside the string
                                result.push_str("\\\"");
                            }
                        } else {
                            // End of input, probably end of string
                            in_string = false;
                            result.push('"');
                        }
                    } else {
                        // Starting a new string
                        in_string = true;
                        result.push('"');
                    }
                }
                '\\' if !escape_next => {
                    escape_next = true;
                    result.push('\\');
                }
                _ => {
                    escape_next = false;
                    result.push(ch);
                }
            }
        }
        
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    // Helper struct to test JSON repair functions without full runner setup
    struct JsonRepairer;
    
    impl JsonRepairer {
        fn repair_json_string(&self, json_str: &str) -> String {
            // Common repair strategies for AI-generated JSON
            let mut repaired = json_str.to_string();
            
            // Strategy 1: Fix unescaped quotes within string values
            repaired = self.fix_unescaped_quotes_in_strings(&repaired);
            
            // Strategy 2: Remove any trailing commas before closing braces/brackets
            repaired = regex::Regex::new(r",(\s*[}\]])").unwrap()
                .replace_all(&repaired, "$1")
                .to_string();
            
            // Strategy 3: Fix common newline issues within strings
            repaired = repaired.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
            
            // Strategy 4: Ensure proper boolean/null values (case sensitive)
            repaired = regex::Regex::new(r":\s*(True|TRUE)\b").unwrap()
                .replace_all(&repaired, ": true")
                .to_string();
            repaired = regex::Regex::new(r":\s*(False|FALSE)\b").unwrap()
                .replace_all(&repaired, ": false")
                .to_string();
            repaired = regex::Regex::new(r":\s*(None|NULL)\b").unwrap()
                .replace_all(&repaired, ": null")
                .to_string();
            
            repaired
        }
        
        fn fix_unescaped_quotes_in_strings(&self, json_str: &str) -> String {
            let mut result = String::with_capacity(json_str.len() * 2);
            let mut chars = json_str.chars().peekable();
            let mut in_string = false;
            let mut escape_next = false;
            
            while let Some(ch) = chars.next() {
                match ch {
                    '"' if !escape_next => {
                        // This is either starting/ending a string or an unescaped quote inside a string
                        if in_string {
                            // Check if this is really the end of the string by looking ahead
                            // Skip whitespace and see if we find a colon, comma, or closing brace/bracket
                            let mut lookahead = chars.clone();
                            let mut found_whitespace_only = true;
                            
                            while let Some(&next_ch) = lookahead.peek() {
                                if next_ch.is_whitespace() {
                                    lookahead.next();
                                } else {
                                    found_whitespace_only = false;
                                    break;
                                }
                            }
                            
                            if let Some(&next_non_ws) = lookahead.peek() {
                                if matches!(next_non_ws, ':' | ',' | '}' | ']') || found_whitespace_only {
                                    // This is likely the end of the string
                                    in_string = false;
                                    result.push('"');
                                } else {
                                    // This is likely an unescaped quote inside the string
                                    result.push_str("\\\"");
                                }
                            } else {
                                // End of input, probably end of string
                                in_string = false;
                                result.push('"');
                            }
                        } else {
                            // Starting a new string
                            in_string = true;
                            result.push('"');
                        }
                    }
                    '\\' if !escape_next => {
                        escape_next = true;
                        result.push('\\');
                    }
                    _ => {
                        escape_next = false;
                        result.push(ch);
                    }
                }
            }
            
            result
        }
    }
    
    #[test]
    fn test_json_repair_unescaped_quotes() {
        let repairer = JsonRepairer;
        
        // Test case 1: Unescaped quotes in reasoning field
        let broken_json = r#"{
    "reasoning": "He said "hello" to me and I responded",
    "actions": []
}"#;
        
        println!("Original broken JSON:\n{}", broken_json);
        let repaired = repairer.repair_json_string(broken_json);
        println!("Repaired JSON:\n{}", repaired);
        
        let parsed: Result<Value, _> = serde_json::from_str(&repaired);
        match &parsed {
            Ok(value) => println!("Successfully parsed: {:?}", value),
            Err(e) => println!("Parse error: {}", e),
        }
        assert!(parsed.is_ok(), "Failed to parse repaired JSON: {}", repaired);
        
        // Test case 2: Multiple unescaped quotes
        let broken_json2 = r#"{
    "reasoning": "The character "John" told "Mary" about the "secret"",
    "actions": []
}"#;
        
        let repaired2 = repairer.repair_json_string(broken_json2);
        let parsed2: Result<Value, _> = serde_json::from_str(&repaired2);
        assert!(parsed2.is_ok(), "Failed to parse repaired JSON with multiple quotes: {}", repaired2);
        
        // Test case 3: Mixed issues (trailing comma + unescaped quotes)
        let broken_json3 = r#"{
    "reasoning": "She said "no" but meant "yes"",
    "actions": [],
}"#;
        
        let repaired3 = repairer.repair_json_string(broken_json3);
        let parsed3: Result<Value, _> = serde_json::from_str(&repaired3);
        assert!(parsed3.is_ok(), "Failed to parse repaired JSON with mixed issues: {}", repaired3);
        
        // Test case 4: Already valid JSON should remain unchanged
        let valid_json = r#"{
    "reasoning": "This is properly escaped \"quote\" content",
    "actions": []
}"#;
        
        let repaired4 = repairer.repair_json_string(valid_json);
        let parsed4: Result<Value, _> = serde_json::from_str(&repaired4);
        assert!(parsed4.is_ok(), "Failed to parse already valid JSON: {}", repaired4);
    }
    
    #[test]
    fn test_fix_unescaped_quotes_in_strings() {
        let repairer = JsonRepairer;
        
        // Test basic unescaped quote
        let input = r#""He said "hello" to me""#;
        let expected = r#""He said \"hello\" to me""#;
        let result = repairer.fix_unescaped_quotes_in_strings(input);
        assert_eq!(result, expected);
        
        // Test multiple quotes
        let input2 = r#""The "big" "red" "apple"""#;
        let expected2 = r#""The \"big\" \"red\" \"apple\"""#;
        let result2 = repairer.fix_unescaped_quotes_in_strings(input2);
        assert_eq!(result2, expected2);
        
        // Test quotes at the end
        let input3 = r#""She said "yes"""#;
        let expected3 = r#""She said \"yes\"""#;
        let result3 = repairer.fix_unescaped_quotes_in_strings(input3);
        assert_eq!(result3, expected3);
    }
}

/// Result of the complete narrative workflow execution
#[derive(Debug)]
pub struct NarrativeWorkflowResult {
    pub triage_result: TriageResult,
    pub actions_taken: Vec<PlannedAction>,
    pub execution_results: Vec<ToolResult>,
    pub cost_estimate: f64,
}